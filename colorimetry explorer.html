<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Colorimetry Explorer</title>
  <style>
    /*
      Colorimetry Explorer â€“ Single page application
      ------------------------------------------------
      This file contains all of the markup, styling and JavaScript required
      to load one or more CSVs exported from a colorimeter and explore the
      resulting colour information. The goal is to remain fully offline and
      self contained with no external dependencies.

      Design notes:
      * CSS variables allow the site to adapt to light or dark mode using
        prefersâ€‘colorâ€‘scheme. We pick sensible defaults and override them
        when dark mode is preferred.
      * A responsive layout divides the interface into a header bar,
        sidebar for sample selection and a main content area with tabs.
      * Charts are drawn using plain SVG for crisp export and to avoid
        reliance on charting libraries. Helper functions further down in
        the file encapsulate common drawing tasks like axes and paths.
    */
    :root {
      --bg: #fdfdfd;
      --fg: #1a1a1a;
      --accent: #0066cc;
      --border: #ccc;
      --panel-bg: #ffffff;
      --hover: #f0f0f0;
      --warning-bg: #fffbe0;
      --warning-fg: #665c00;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #1e1e1e;
        --fg: #eaeaea;
        --accent: #4ea8de;
        --border: #444;
        --panel-bg: #2c2c2c;
        --hover: #353535;
        --warning-bg: #665c00;
        --warning-fg: #fff1a8;
      }
    }
    /* Explicit dark mode toggler overrides via .dark class on the html element.
       This allows users to force dark mode regardless of system preferences. */
    :root.dark {
      /* When the document has a .dark class, override colour variables regardless of system prefs */
      --bg: #1e1e1e;
      --fg: #eaeaea;
      --accent: #4ea8de;
      --border: #444;
      --panel-bg: #2c2c2c;
      --hover: #353535;
      --warning-bg: #665c00;
      --warning-fg: #fff1a8;
    }
    /* Similarly, an explicit .light class forces light variables even if the OS prefers dark mode. */
    :root.light {
      --bg: #fdfdfd;
      --fg: #1a1a1a;
      --accent: #0066cc;
      --border: #ccc;
      --panel-bg: #ffffff;
      --hover: #f0f0f0;
      --warning-bg: #fffbe0;
      --warning-fg: #665c00;
    }

    /* Enlarge the entire UI by scaling the page up by 1.25Ã—. This improves readability
       and gives charts and controls more breathing room. */
    body {
      /* Increase the default font size to zoom the interface to ~125% without
         using CSS transforms. This avoids introducing horizontal scrollbars
         while still enlarging text and controls. */
      font-size: 1.25em;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      background-color: var(--bg);
      color: var(--fg);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.5rem 1rem;
      border-bottom: 1px solid var(--border);
      background-color: var(--panel-bg);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    header h1 {
      font-size: 1.2rem;
      margin: 0;
      white-space: nowrap;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      flex: 1;
    }
    .toolbar label {
      font-size: 0.9rem;
      margin-right: 0.25rem;
    }
    .toolbar input[type="file"] {
      display: none;
    }
    .upload-zone {
      border: 2px dashed var(--border);
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }
    .upload-zone.dragover {
      border-color: var(--accent);
      background-color: var(--hover);
    }
    select, input[type="search"], button {
      padding: 0.3rem 0.5rem;
      font-size: 0.9rem;
      border: 1px solid var(--border);
      border-radius: 4px;
      background-color: var(--panel-bg);
      color: var(--fg);
    }
    button {
      cursor: pointer;
    }
    button:hover {
      background-color: var(--hover);
    }
    #container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    #sidebar {
      width: 300px;
      min-width: 200px;
      border-right: 1px solid var(--border);
      overflow-y: auto;
      background-color: var(--panel-bg);
      flex-shrink: 0;
    }
    #divider {
      width: 5px;
      cursor: col-resize;
      background-color: var(--border);
    }
    #divider:hover, #divider.dragging {
      background-color: var(--accent);
    }
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #samples-table, #compare-table {
      width: 100%;
      border-collapse: collapse;
    }
    #samples-table th, #samples-table td,
    #compare-table th, #compare-table td {
      padding: 0.3rem 0.5rem;
      border-bottom: 1px solid var(--border);
      white-space: nowrap;
    }
    #samples-table th, #compare-table th {
      position: sticky;
      top: 0;
      background-color: var(--panel-bg);
      z-index: 1;
    }
    #samples-table tr:hover, #compare-table tr:hover {
      background-color: var(--hover);
    }
    .warning {
      background-color: var(--warning-bg);
      color: var(--warning-fg);
      padding: 0.5rem;
      border-bottom: 1px solid var(--border);
    }
    .tabs {
      display: flex;
      border-bottom: 1px solid var(--border);
    }
    .tabs button {
      flex: 1;
      padding: 0.5rem;
      border: none;
      border-bottom: 2px solid transparent;
      background-color: var(--panel-bg);
      color: var(--fg);
    }
    .tabs button.active {
      border-bottom-color: var(--accent);
      font-weight: bold;
    }
    .tab-content {
      flex: 1;
      overflow: auto;
      padding: 1rem;
    }
    .beer-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      margin-bottom: 1rem;
      font-size: 0.9rem;
    }
    .beer-controls p {
      flex-basis: 100%;
      margin: 0;
    }
    .beer-controls label {
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }
    .beer-controls select,
    .beer-controls input {
      font-size: 0.9rem;
    }
    .beer-sample-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .beer-sample-card {
      background-color: var(--panel-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.65rem 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }
    .beer-sample-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .beer-sample-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 600;
    }
    .beer-sample-code {
      font-size: 0.75rem;
      opacity: 0.7;
    }
    .beer-color-chip {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid rgba(0, 0, 0, 0.15);
    }
    .beer-sample-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      font-size: 0.9rem;
    }
    .beer-sample-controls label {
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }
    .beer-sample-controls input[type="text"] {
      min-width: 120px;
    }
    .beer-extra-wrapper {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      justify-content: flex-end;
      margin-left: auto;
    }
    .beer-extra-row {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.4rem;
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 0.8rem;
      white-space: nowrap;
    }
    .beer-main-row {
      font-weight: normal;
    }
    .beer-extra-label {
      font-size: 0.75rem;
      font-weight: 600;
    }
    .beer-extra-row.disabled {
      opacity: 0.55;
    }
    .beer-extra-row label {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      margin: 0;
    }
    .beer-extra-row input[type="text"] {
      width: 70px;
      font-size: 0.8rem;
    }
    .beer-extra-row select {
      font-size: 0.8rem;
      max-width: 180px;
    }
    .beer-summary {
      font-size: 0.85rem;
      opacity: 0.8;
    }
    .beer-results {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .beer-swatch-strip {
      display: flex;
      gap: 0.5rem;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding-bottom: 0.25rem;
    }
    .beer-swatch {
      min-width: 100px;
      width: 100px;
      border-radius: 4px;
      padding: 0.35rem;
      box-sizing: border-box;
      font-size: 0.8rem;
    }
    .beer-swatch strong {
      display: block;
      margin-bottom: 0.25rem;
    }
    .beer-linearity {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      align-items: center;
      font-size: 0.8rem;
    }
    .beer-linearity .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 0.35rem;
    }
    .beer-path-list {
      margin: 0;
      padding-left: 1.1rem;
      font-size: 0.85rem;
    }
    .beer-path-list li {
      margin-bottom: 0.2rem;
    }
    .beer-error {
      background-color: var(--warning-bg);
      color: var(--warning-fg);
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    .beer-empty {
      font-size: 0.9rem;
      opacity: 0.8;
    }
    .beer-compare-grid {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .beer-compare-card {
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem 0.75rem;
      background-color: var(--panel-bg);
      display: grid;
      grid-template-columns: minmax(160px, 220px) 1fr;
      align-items: center;
      column-gap: 0.75rem;
      row-gap: 0.5rem;
    }
    .beer-compare-card.disabled {
      opacity: 0.35;
    }
    .beer-compare-header {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      font-weight: 600;
      font-size: 0.9rem;
    }
    .beer-compare-strip {
      display: flex;
      flex-wrap: nowrap;
      gap: 0.35rem;
      overflow-x: auto;
      padding-bottom: 0.25rem;
      justify-content: flex-end;
      justify-self: end;
    }
    .beer-compare-card .beer-empty,
    .beer-compare-card .beer-error {
      grid-column: 1 / -1;
    }
    @media (max-width: 700px) {
      .beer-compare-card {
        grid-template-columns: 1fr;
      }
      .beer-compare-strip {
        justify-self: stretch;
        justify-content: flex-start;
      }
    }
    .beer-compare-swatch {
      width: 56px;
      height: 56px;
      border-radius: 4px;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding: 0.2rem;
      font-size: 0.65rem;
      font-weight: 600;
      box-sizing: border-box;
    }
    .beer-compare-swatch span {
      background-color: rgba(0,0,0,0.45);
      color: #fff;
      border-radius: 3px;
      padding: 0 0.2rem;
    }
    svg.chart {
      width: 100%;
      /* Default chart height */
      height: 500px;
      display: block;
      color: var(--fg);
    }
    #abChart, #lChart {
      height: 600px;
    }
    #spectrumChart {
      height: 750px;
    }
    svg.chart text {
      fill: var(--fg);
      font-size: 1em;
      font-family: inherit;
    }

    /* When the container has the hide-main class, hide the right hand
       panel (charts) and allow the sidebar to expand to the full width. */
    #container.hide-main #main {
      display: none;
    }
    #container.hide-main #divider {
      display: none;
    }
    #container.hide-main #sidebar {
      width: auto;
      max-width: none;
      flex: 1;
    }
    .details-card {
      background-color: var(--panel-bg);
      border: 1px solid var(--border);
      padding: 1rem;
      border-radius: 4px;
      margin-top: 1rem;
    }
    .details-card table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5rem;
    }
    .details-card th, .details-card td {
      padding: 0.2rem 0.5rem;
      border-bottom: 1px solid var(--border);
      text-align: center;
    }
    .tooltip {
      position: fixed;
      pointer-events: none;
      padding: 0.3rem 0.5rem;
      background-color: var(--panel-bg);
      color: var(--fg);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 0.8rem;
      z-index: 1000;
      white-space: nowrap;
    }
    #paste-area {
      width: 100%;
      height: 100px;
      font-family: monospace;
      margin-top: 0.5rem;
    }
  </style>
</head>
<body>
  <header>
    <h1 data-i18n="title">Colorimetry Explorer</h1>
    <div class="toolbar">
      <div class="upload-zone" id="uploadZone"><span data-i18n="drop">Drop or select CSVâ€¦</span><input type="file" id="fileInput" multiple accept=".csv" /></div>
      <label><span data-i18n="labelIlluminant">Illuminant:</span><select id="illuminantFilter"><option value="" data-i18n="all">All</option></select></label>
      <label><span data-i18n="labelGroupIlluminant">Group by Illuminant:</span><input type="checkbox" id="groupByIlluminant" /></label>
      <label><span data-i18n="labelHideUnselected">Hide non-selected:</span><input type="checkbox" id="hideUnselected" /></label>
      <input type="search" id="searchBox" data-i18n-placeholder="searchPlaceholder" placeholder="Search Name or No." />
      <button id="saveProject" data-i18n="saveProject">Save Project</button>
      <button id="exportProjectJson" data-i18n="exportProjectJson">Export JSON</button>
      <button id="importProjectJson" data-i18n="importProjectJson">Import JSON</button>
      <input type="file" id="projectImport" accept="application/json,.json" style="display:none" />
      <!-- Dark mode toggle button. Clicking this button toggles a .dark class on the root element
           and persists the choice in localStorage. -->
      <button id="themeToggle" data-i18n-title="toggleDark" title="Toggle dark mode" style="margin-left:auto">ðŸŒ“</button>
      <button id="languageToggle" data-i18n-title="changeLanguage">FR</button>
      <!-- Toggle visibility of the chart panel. When clicked, this button collapses the
           main panel containing the charts so that the sample sidebar fills the available space.
           Clicking again restores the charts. The button label updates to indicate the
           current state. -->
      <button id="toggleMainPanel" data-i18n-title="hideCharts" title="Hide charts">â‡„</button>
    </div>
  </header>
  <div id="container">
    <aside id="sidebar">
      <div style="padding:0.5rem">
        <!-- Buttons to delete selected or unselected samples from the program. -->
        <button id="deleteSamples" data-i18n="deleteSelected" title="Remove selected samples from the list">Delete Selected</button>
        <button id="deleteUnselected" data-i18n="deleteUnselected" title="Remove samples that are not selected">Delete Unselected</button>
      </div>
      <div class="warning" id="warning" style="display:none"></div>
      <table id="samples-table" aria-label="Samples">
        <thead>
          <tr>
            <th><input type="checkbox" id="selectAll" title="Select All/None" /></th>
            <th data-i18n="color">Color</th>
            <th data-i18n="no">No.</th>
            <th data-i18n="name">Name</th>
            <th data-i18n="date">Date</th>
            <th data-i18n="time">Time</th>
            <th data-i18n="avg">Avg.</th>
            <th data-i18n="illum">Illum.</th>
            <th data-i18n="lstar">L*</th>
            <th data-i18n="astar">a*</th>
            <th data-i18n="bstar">b*</th>
            <th data-i18n="hazen">Hazen</th>
            <th data-i18n="gardner">Gardner</th>
            <th data-i18n="saybolt">Saybolt</th>
            <th data-i18n="astm">ASTM</th>
            <th data-i18n="ptco">Pt-Co</th>
          </tr>
        </thead>
      <tbody></tbody>
      </table>
    </aside>
    <div id="divider" role="separator" aria-orientation="vertical"></div>
    <main id="main">
      <div class="tabs">
        <button class="active" data-tab="scales">Scales</button>
        <button data-tab="cielab">CIELAB</button>
        <button data-tab="spectrum">Spectrum</button>
        <button data-tab="beer">Color Extrapolation</button>
        <button data-tab="beer-compare">Color Comparison</button>
        <button data-tab="compare">Compare</button>
        <button data-tab="details">Details</button>
      </div>
      <div class="tab-content" id="tab-scales" style="display:block">
        <svg class="chart" id="scalesChart" aria-label="Scales chart"></svg>
      </div>
      <div class="tab-content" id="tab-cielab" style="display:none">
        <div style="display:flex;flex-wrap:wrap;gap:1rem">
          <!-- Allocate more space to the a*â€“b* plane by giving it a larger flex value. -->
          <svg class="chart" id="abChart" style="flex:3" aria-label="a-b* plane"></svg>
          <!-- The L* scale occupies less horizontal space compared to the a*b* plane. -->
          <svg class="chart" id="lChart" style="flex:1" aria-label="L* scale"></svg>
        </div>
      </div>
      <div class="tab-content" id="tab-spectrum" style="display:none">
        <div style="margin-bottom:0.5rem">
          <label><input type="checkbox" id="logScale"> log10(A)</label>
          <label style="margin-left:1rem"><input type="checkbox" id="smoothToggle"> Smooth</label>
          <label style="margin-left:0.5rem">Level:<input type="range" id="smoothWindow" min="3" max="15" step="2" value="5" style="width:100px" /></label>
          <label style="margin-left:1rem"><input type="checkbox" id="shadeArea"> Shade area</label>
          <label style="margin-left:1rem">Y max:<input type="number" id="yMaxInput" min="0" step="0.1" style="width:60px"></label>
        </div>
        <svg class="chart" id="spectrumChart" aria-label="Spectrum chart"></svg>
      </div>
      <div class="tab-content" id="tab-beer" style="display:none">
        <div class="beer-controls">
          <p>Enter the measurement path length for each selected sample to extrapolate colours using the Beerâ€“Lambert law.</p>
          <label><input type="checkbox" id="beerClampNeg" checked> Clamp negatives to 0</label>
          <label><input type="checkbox" id="beerBaseline"> Baseline correction â‰¥650&nbsp;nm</label>
          <label><input type="checkbox" id="beerForceOrigin"> Force through origin</label>
          <label>Color reference:
            <select id="beerColorRef">
              <option value="d65">D65 / 10Â°</option>
              <option value="c2">C / 2Â°</option>
            </select>
          </label>
        </div>
        <div id="beerSampleList" class="beer-sample-list">
          <div class="beer-empty">Select one or more samples to begin.</div>
        </div>
      </div>
      <div class="tab-content" id="tab-beer-compare" style="display:none">
        <div id="beerCompareList" class="beer-compare-grid">
          <div class="beer-empty">No samples selected.</div>
        </div>
      </div>
      <div class="tab-content" id="tab-compare" style="display:none">
        <table id="compare-table" aria-label="Compare samples">
          <thead>
            <tr>
              <th>Ref</th>
              <th>Name</th>
              <th>Date</th>
              <th>Time</th>
              <th>Illum.</th>
              <th>L*</th>
              <th>a*</th>
              <th>b*</th>
              <th>Hazen</th>
              <th>Gardner</th>
              <th>Saybolt</th>
              <th>ASTM</th>
              <th>Pt-Co</th>
              <th>Î”E</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="tab-content" id="tab-details" style="display:none">
        <div id="detailsCard" class="details-card">No sample selected.</div>
      </div>
    </main>
  </div>
    <div id="tooltip" class="tooltip" style="display:none"></div>
  <script>
  (function() {
    const appScript = document.currentScript;
    const translations = {
      en: {
        title: 'Colorimetry Explorer',
        drop: 'Drop or select CSVâ€¦',
        labelIlluminant: 'Illuminant:',
        labelGroupIlluminant: 'Group by Illuminant:',
        labelHideUnselected: 'Hide non-selected:',
        searchPlaceholder: 'Search Name or No.',
        saveProject: 'Save Project',
        exportProjectJson: 'Export JSON',
        importProjectJson: 'Import JSON',
        toggleDark: 'Toggle dark mode',
        changeLanguage: 'Change language',
        hideCharts: 'Hide charts',
        showCharts: 'Show charts',
        deleteSelected: 'Delete Selected',
        deleteUnselected: 'Delete Unselected',
        color: 'Color',
        no: 'No.',
        name: 'Name',
        date: 'Date',
        time: 'Time',
        avg: 'Avg.',
        illum: 'Illum.',
        lstar: 'L*',
        astar: 'a*',
        bstar: 'b*',
        hazen: 'Hazen',
        gardner: 'Gardner',
        saybolt: 'Saybolt',
        astm: 'ASTM',
        ptco: 'Pt-Co',
        all: 'All',
        couldNotSaveFile: 'Could not save file.',
        invalidProjectFile: 'Project file is invalid.',
        noDataToSave: 'No data to save.',
        noUnselectedToDelete: 'No unselected samples to delete.',
        noSamplesToDelete: 'No samples selected to delete.'
      },
      fr: {
        title: 'Explorateur ColorimÃ©trique',
        drop: 'DÃ©poser ou sÃ©lectionner CSVâ€¦',
        labelIlluminant: 'Illuminant\u00a0:',
        labelGroupIlluminant: 'Grouper par illuminant\u00a0:',
        labelHideUnselected: 'Masquer non sÃ©lectionnÃ©s\u00a0:',
        searchPlaceholder: 'Rechercher Nom ou N\u00b0',
        saveProject: 'Enregistrer le projet',
        exportProjectJson: 'Exporter JSON',
        importProjectJson: 'Importer JSON',
        toggleDark: 'Basculer mode sombre',
        changeLanguage: 'Changer de langue',
        hideCharts: 'Cacher les graphiques',
        showCharts: 'Afficher les graphiques',
        deleteSelected: 'Supprimer sÃ©lectionnÃ©s',
        deleteUnselected: 'Supprimer non sÃ©lectionnÃ©s',
        color: 'Couleur',
        no: 'N\u00b0',
        name: 'Nom',
        date: 'Date',
        time: 'Heure',
        avg: 'Moy.',
        illum: 'Illum.',
        lstar: 'L*',
        astar: 'a*',
        bstar: 'b*',
        hazen: 'Hazen',
        gardner: 'Gardner',
        saybolt: 'Saybolt',
        astm: 'ASTM',
        ptco: 'Pt-Co',
        all: 'Tous',
        couldNotSaveFile: 'Impossible d\u2019enregistrer le fichier.',
        invalidProjectFile: 'Le fichier du projet est invalide.',
        noDataToSave: 'Aucune donnÃ©e Ã  enregistrer.',
        noUnselectedToDelete: 'Aucun Ã©chantillon non sÃ©lectionnÃ© Ã  supprimer.',
        noSamplesToDelete: 'Aucun Ã©chantillon sÃ©lectionnÃ© Ã  supprimer.'
      }
    };
    // State management
    const state = {
      // parsed samples are kept entirely in memory and never persisted
      samples: [],
      // currently selected sample ids for overlay
      selected: new Set(),
      selectedOrder: [],
      // UI toggles â€“ these may be persisted
      activeTab: 'scales',
      logScale: false,
      smooth: false,
      smoothWindow: 5,
      shadeArea: false,
      yMax: null,
      groupByIlluminant: false,
      hideUnselected: false,
      // perâ€‘session filters and search text (not persisted)
      illuminantFilter: '',
      search: '',
      lastClicked: null,
      // explicit theme string: 'light' or 'dark'
      theme: 'light',
      language: 'en',
      // id of sample chosen as comparison reference
      compareRef: null,
      // project name for saving/loading
      projectName: document.title,
      // beer-lambert options and stored paths
      beerClampNeg: true,
      beerBaseline: false,
      beerForceOrigin: false,
      beerColorRef: 'd65',
      beerPaths: {},
    };

    function t(key) {
      return (translations[state.language] && translations[state.language][key]) || translations.en[key] || key;
    }

    function applyTranslations() {
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const k = el.dataset.i18n;
        if (k === 'title' && state.projectName) return;
        if (k) el.textContent = t(k);
      });
      document.querySelectorAll('[data-i18n-title]').forEach(el => {
        const k = el.dataset.i18nTitle;
        if (k) el.title = t(k);
      });
      document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const k = el.dataset.i18nPlaceholder;
        if (k) el.placeholder = t(k);
      });
      if (!state.projectName) document.title = t('title');
    }

    function setProjectTitle(name) {
      state.projectName = name;
      document.title = name || t('title');
      const h1 = document.querySelector('header h1');
      if (h1) h1.textContent = name || t('title');
    }
    const SATURATION_LIMIT = 4.0;
    const COLOR_OPTIONS = [
      '#e6194b','#3cb44b','#ffe119','#0082c8','#f58231',
      '#911eb4','#46f0f0','#f032e6','#d2f53c','#fabebe',
      '#008080','#e6beff','#aa6e28','#800000','#aaffc3'
    ];
    function applyTheme() {
      const docEl = document.documentElement;
      docEl.classList.remove('dark', 'light');
      docEl.classList.add(state.theme);
    }
    function ensureSampleColors(samples) {
      samples.forEach((sample, idx) => {
        if (!sample.color) {
          sample.color = COLOR_OPTIONS[idx % COLOR_OPTIONS.length];
        }
      });
    }
    function buildProjectPayload() {
      return { ...state, selected: Array.from(state.selected) };
    }
    function applyProjectData(proj) {
      if (!proj || typeof proj !== 'object' || !Array.isArray(proj.samples)) return false;
      state.samples = proj.samples;
      ensureSampleColors(state.samples);
      const sampleIds = new Set(state.samples.map(s => s.id));
      const selected = Array.isArray(proj.selected) ? proj.selected.filter(id => sampleIds.has(id)) : [];
      state.selected = new Set(selected);
      const selectedOrder = Array.isArray(proj.selectedOrder) ? proj.selectedOrder.filter(id => sampleIds.has(id)) : [];
      state.selectedOrder = selectedOrder.length ? selectedOrder : Array.from(state.selected);
      state.beerPaths = proj.beerPaths || {};
      [
        'activeTab','logScale','smooth','smoothWindow','shadeArea','yMax','groupByIlluminant','hideUnselected',
        'illuminantFilter','search','theme','language','compareRef','projectName','beerClampNeg','beerBaseline',
        'beerForceOrigin','beerColorRef'
      ].forEach(key => {
        if (proj.hasOwnProperty(key)) state[key] = proj[key];
      });
      setProjectTitle(state.projectName || '');
      return true;
    }
    function syncControlsFromState() {
      document.getElementById('groupByIlluminant').checked = !!state.groupByIlluminant;
      document.getElementById('hideUnselected').checked = !!state.hideUnselected;
      document.getElementById('illuminantFilter').value = state.illuminantFilter || '';
      document.getElementById('searchBox').value = state.search || '';
      document.getElementById('logScale').checked = !!state.logScale;
      document.getElementById('smoothToggle').checked = !!state.smooth;
      document.getElementById('smoothWindow').value = state.smoothWindow;
      document.getElementById('shadeArea').checked = !!state.shadeArea;
      document.getElementById('yMaxInput').value = state.yMax !== null ? state.yMax : '';
      const beerClamp = document.getElementById('beerClampNeg');
      if (beerClamp) beerClamp.checked = !!state.beerClampNeg;
      const beerBaseline = document.getElementById('beerBaseline');
      if (beerBaseline) beerBaseline.checked = !!state.beerBaseline;
      const beerForce = document.getElementById('beerForceOrigin');
      if (beerForce) beerForce.checked = !!state.beerForceOrigin;
      const beerRef = document.getElementById('beerColorRef');
      if (beerRef) beerRef.value = state.beerColorRef || 'd65';
      document.querySelectorAll('.tabs button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === state.activeTab);
      });
      document.querySelectorAll('.tab-content').forEach(tc => tc.style.display = 'none');
      const activePanel = document.getElementById('tab-' + state.activeTab);
      if (activePanel) activePanel.style.display = 'block';
      const languageToggle = document.getElementById('languageToggle');
      languageToggle.textContent = state.language === 'en' ? 'FR' : 'EN';
    }
    // Attempt to load persisted UI state
    try {
      const stored = JSON.parse(localStorage.getItem('colorimetryState') || '{}');
      // Only assign known persisted keys to avoid clobbering arrays/sets
      ['activeTab','logScale','smooth','smoothWindow','shadeArea','yMax','groupByIlluminant','hideUnselected','theme','language','projectName','beerClampNeg','beerBaseline','beerForceOrigin','beerColorRef'].forEach(key => {
        if (stored.hasOwnProperty(key)) state[key] = stored[key];
      });
    } catch (e) {
      // ignore invalid stored state
    }
    const projectEl = document.getElementById('projectData');
    if (projectEl) {
      try {
        const proj = JSON.parse(projectEl.textContent);
        applyProjectData(proj);
      } catch (e) {
        console.error('Failed to load project data', e);
      }
    }
    if (!projectEl) {
      state.projectName = '';
    }
    setProjectTitle(state.projectName);
    if (!projectEl) persistState();
    applyTranslations();
    // Save state
    function persistState() {
      // Only persist UI toggles as requested; samples, selections, search, filters
      // are intentionally not stored across sessions for reliability.
        const toStore = {
          activeTab: state.activeTab,
          logScale: state.logScale,
          smooth: state.smooth,
          smoothWindow: state.smoothWindow,
          shadeArea: state.shadeArea,
          yMax: state.yMax,
          groupByIlluminant: state.groupByIlluminant,
          hideUnselected: state.hideUnselected,
          theme: state.theme,
          language: state.language,
          projectName: state.projectName,
          beerClampNeg: state.beerClampNeg,
          beerBaseline: state.beerBaseline,
          beerForceOrigin: state.beerForceOrigin,
          beerColorRef: state.beerColorRef,
        };
      try {
        localStorage.setItem('colorimetryState', JSON.stringify(toStore));
      } catch (err) {
        // ignore storage errors (e.g. quota exceeded)
      }
    }
    // Utility functions
    function sanitizeNumber(str, decimalSeparator) {
      if (!str) return NaN;
      let s = str.trim();
      // treat placeholder dashes (including em dash) as missing
      if (/^[\-\u2014]+$/.test(s)) return NaN;
      // unify thousands grouping by removing spaces
      s = s.replace(/\s/g,'');
      // replace decimal separator with dot
      if (decimalSeparator === ',') {
        s = s.replace(',', '.');
      }
      const n = parseFloat(s);
      return isNaN(n) ? NaN : n;
    }
    function sanitizeSpectrumNumber(str, decimalSeparator, saturationLimit) {
      const numeric = sanitizeNumber(str, decimalSeparator);
      if (isFinite(numeric)) return numeric;
      const raw = (str ?? '').trim();
      if (!raw) return NaN;
      return saturationLimit;
    }
    function assignDefaultColors(samples) {
      let idx = state.samples.length;
      samples.forEach(s => {
        s.color = COLOR_OPTIONS[idx % COLOR_OPTIONS.length];
        idx++;
      });
    }
    // Data for Beerâ€“Lambert colour estimation
    const BEER_WAVELENGTHS = Array.from({length: 31}, (_, i) => 400 + i * 10);
    const BEER_XBAR_10 = [0.0191097,0.084736,0.204492,0.314679,0.383734,0.370702,0.302273,0.195618,0.080507,0.016172,0.003816,0.037465,0.117749,0.236491,0.376772,0.529826,0.705224,0.878655,1.01416,1.11852,1.12399,1.03048,0.856297,0.647467,0.431567,0.268329,0.152568,0.0812606,0.0408508,0.0199413,0.00957688];
    const BEER_YBAR_10 = [0.0020044,0.008756,0.021391,0.038676,0.062077,0.089456,0.128201,0.18519,0.253589,0.339133,0.460777,0.606741,0.761757,0.875211,0.961988,0.991761,0.99734,0.955552,0.868934,0.777405,0.658341,0.527963,0.398057,0.283493,0.179828,0.107633,0.060281,0.0318004,0.0159051,0.0077488,0.00371774];
    const BEER_ZBAR_10 = [0.0860109,0.389366,0.972542,1.55348,1.96728,1.9948,1.74537,1.31756,0.772125,0.415254,0.218502,0.112044,0.060709,0.030451,0.013676,0.003988,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    const BEER_D65_SPD = [82.7549,91.486,93.4318,86.6823,104.865,117.008,117.812,114.861,115.923,108.811,109.354,107.802,104.79,107.689,104.405,104.046,100.0,96.3342,95.788,88.6856,90.0062,89.5991,87.6987,83.2886,83.6992,80.0268,80.2146,82.2778,78.2842,69.7213,71.6091];
    const BEER_XBAR_2 = [0.01431,0.04351,0.13438,0.2839,0.34828,0.3362,0.2908,0.19536,0.09564,0.03201,0.0049,0.0093,0.06327,0.1655,0.2904,0.4334499,0.5945,0.7621,0.9163,1.0263,1.0622,1.0026,0.8544499,0.6424,0.4479,0.2835,0.1649,0.0874,0.04677,0.0227,0.01135916];
    const BEER_YBAR_2 = [0.000396,0.00121,0.004,0.0116,0.023,0.038,0.06,0.09098,0.13902,0.20802,0.323,0.503,0.71,0.862,0.954,0.9949501,0.995,0.952,0.87,0.757,0.631,0.503,0.381,0.265,0.175,0.107,0.061,0.032,0.017,0.00821,0.004102];
    const BEER_ZBAR_2 = [0.06785001,0.2074,0.6456,1.3856,1.74706,1.77211,1.6692,1.28764,0.8129501,0.46518,0.272,0.1582,0.07824999,0.04216,0.0203,0.008749999,0.0039,0.0021,0.001650001,0.0011,0.0008,0.00034,0.00019,0.00005,0.00002,0,0,0,0,0,0];
    const BEER_C_SPD = [63.3,80.6,98.1,112.4,121.5,124.0,123.1,123.8,123.9,120.7,112.1,102.3,96.9,98.0,102.1,105.2,105.3,102.3,97.8,93.2,89.7,88.4,88.1,88.0,87.8,88.2,87.9,86.3,84.0,80.2,76.3];
    const BEER_REFERENCES = {
      d65: {
        label: 'D65 / 10Â°',
        xBar: BEER_XBAR_10,
        yBar: BEER_YBAR_10,
        zBar: BEER_ZBAR_10,
        spd: BEER_D65_SPD,
      },
      c2: {
        label: 'C / 2Â°',
        xBar: BEER_XBAR_2,
        yBar: BEER_YBAR_2,
        zBar: BEER_ZBAR_2,
        spd: BEER_C_SPD,
      }
    };
    const BEER_DEPTHS = (() => {
      const depths = new Set([0, 0.033, 0.05, 0.1]);
      for (let d = 0.2; d <= 2.0001; d += 0.2) depths.add(parseFloat(d.toFixed(3)));
      return Array.from(depths).sort((a,b) => a - b);
    })();
    const BEER_PATH_UNITS = ['mm','cm','m'];
    function normalizeBeerUnit(unit) {
      return BEER_PATH_UNITS.includes(unit) ? unit : 'mm';
    }
    function makeDefaultBeerExtra() {
      return { enabled: false, raw: '', unit: 'mm', sourceId: '' };
    }
    function normalizeBeerEntryStructure(entry) {
      const normalized = {
        main: { raw: '', unit: 'mm' },
        extras: [makeDefaultBeerExtra(), makeDefaultBeerExtra()]
      };
      if (!entry) return normalized;
      if (typeof entry.raw === 'string' || entry.unit) {
        normalized.main.raw = typeof entry.raw === 'string' ? entry.raw : '';
        normalized.main.unit = normalizeBeerUnit(entry.unit);
        return normalized;
      }
      if (entry.main) {
        normalized.main.raw = typeof entry.main.raw === 'string' ? entry.main.raw : '';
        normalized.main.unit = normalizeBeerUnit(entry.main.unit);
      }
      if (Array.isArray(entry.extras) && entry.extras.length) {
        normalized.extras = entry.extras.slice(0, 2).map(extra => ({
          enabled: !!extra.enabled,
          raw: typeof extra.raw === 'string' ? extra.raw : '',
          unit: normalizeBeerUnit(extra.unit),
          sourceId: extra && extra.sourceId != null ? String(extra.sourceId) : ''
        }));
      }
      while (normalized.extras.length < 2) normalized.extras.push(makeDefaultBeerExtra());
      return normalized;
    }
    function ensureBeerEntry(sampleId) {
      if (!state.beerPaths) state.beerPaths = {};
      const normalized = normalizeBeerEntryStructure(state.beerPaths[sampleId]);
      state.beerPaths[sampleId] = normalized;
      return normalized;
    }
    const beerState = {
      results: {}
    };
    function beerMedian(values) {
      const nums = values.filter(v => typeof v === 'number' && !isNaN(v));
      if (nums.length === 0) return 0;
      const sorted = nums.slice().sort((a,b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      if (sorted.length % 2 === 0) return (sorted[mid - 1] + sorted[mid]) / 2;
      return sorted[mid];
    }
    function computeBeerColours(slopes, intercepts, depths, reference) {
      const spd = reference.spd;
      const xBar = reference.xBar;
      const yBar = reference.yBar;
      const zBar = reference.zBar;
      const delta = 10;
      let denom = 0;
      for (let i = 0; i < BEER_WAVELENGTHS.length; i++) {
        denom += spd[i] * yBar[i];
      }
      const k = 100 / (denom * delta);
      let Xn = 0, Yn = 0, Zn = 0;
      for (let i = 0; i < BEER_WAVELENGTHS.length; i++) {
        Xn += spd[i] * xBar[i];
        Yn += spd[i] * yBar[i];
        Zn += spd[i] * zBar[i];
      }
      Xn *= k * delta;
      Yn *= k * delta;
      Zn *= k * delta;
      const results = depths.map(depth => {
        let X = 0, Y = 0, Z = 0;
        for (let i = 0; i < BEER_WAVELENGTHS.length; i++) {
          const absorbance = slopes[i] * depth + intercepts[i];
          const trans = Math.pow(10, -absorbance);
          X += spd[i] * xBar[i] * trans;
          Y += spd[i] * yBar[i] * trans;
          Z += spd[i] * zBar[i] * trans;
        }
        X *= k * delta;
        Y *= k * delta;
        Z *= k * delta;
        const eps = 216 / 24389;
        const kappa = 24389 / 27;
        const f = (t) => t > eps ? Math.cbrt(t) : (kappa * t + 16) / 116;
        const xr = X / Xn;
        const yr = Y / Yn;
        const zr = Z / Zn;
        const fx = f(xr);
        const fy = f(yr);
        const fz = f(zr);
        const L = 116 * fy - 16;
        const a = 500 * (fx - fy);
        const b = 200 * (fy - fz);
        const Xnorm = X / 100;
        const Ynorm = Y / 100;
        const Znorm = Z / 100;
        const gamma = (u) => u <= 0.0031308 ? 12.92 * u : 1.055 * Math.pow(u, 1/2.4) - 0.055;
        let rLin = 3.2406 * Xnorm - 1.5372 * Ynorm - 0.4986 * Znorm;
        let gLin = -0.9689 * Xnorm + 1.8758 * Ynorm + 0.0415 * Znorm;
        let bLin = 0.0557 * Xnorm - 0.2040 * Ynorm + 1.0570 * Znorm;
        const toDisplay = (val) => {
          const clamped = Math.min(Math.max(val, 0), 1);
          return Math.round(gamma(clamped) * 255);
        };
        const r = toDisplay(rLin);
        const g = toDisplay(gLin);
        const bl = toDisplay(bLin);
        return { depth_m: depth, L, a, b, X, Y, Z, srgb: [r, g, bl] };
      });
      return { results, Xn, Yn, Zn };
    }
    function savitzkyGolay(y, windowSize) {
      // Very simple Savitzky-Golay smoothing (no derivative). Assumes windowSize is odd.
      const half = Math.floor(windowSize/2);
      const coeff = [];
      // For smoothing (polynomial order 2) we precompute coefficients for efficiency.
      // Using symmetric coefficients: central point weight high, outer low.
      for (let i=-half;i<=half;i++) {
        const w = (half+1-Math.abs(i));
        coeff.push(w);
      }
      const sumCoeff = coeff.reduce((a,b)=>a+b,0);
      const smoothed = [];
      for (let i=0;i<y.length;i++) {
        let acc = 0;
        let wsum = 0;
        for (let j=-half;j<=half;j++) {
          const idx = i+j;
          if (idx>=0 && idx<y.length && isFinite(y[idx])) {
            const w = coeff[j+half];
            acc += y[idx]*w;
            wsum += w;
          }
        }
        smoothed.push(acc / wsum);
      }
      return smoothed;
    }

    // ================================
    // Color conversions
    // White points (XYZ, normalized Y=100)
    const WP = {
      D65_2:  [95.047, 100.000, 108.883],
      D65_10: [94.811, 100.000, 107.304],
      C_2:    [98.074, 100.000, 118.232],
      C_10:   [97.285, 100.000, 116.145],
    };
    // Bradford CAT matrices
    const M = [
      [ 0.8951, 0.2664, -0.1614],
      [-0.7502, 1.7135,  0.0367],
      [ 0.0389,-0.0685,  1.0296]
    ];
    const Minv = [
      [ 0.9869929, -0.1470543, 0.1599627],
      [ 0.4323053,  0.5183603, 0.0492912],
      [-0.0085287,  0.0400428, 0.9684867]
    ];
    function mul3x3v(m, v){
      return [
        m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2],
        m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2],
        m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2],
      ];
    }
    function divVec(a,b){ return [a[0]/b[0], a[1]/b[1], a[2]/b[2]]; }
    function mulVec(a,b){ return [a[0]*b[0], a[1]*b[1], a[2]*b[2]]; }
    function bradfordAdaptXYZ(XYZ, srcWP, dstWP){
      const srcLMS = mul3x3v(M, srcWP);
      const dstLMS = mul3x3v(M, dstWP);
      const scale = divVec(dstLMS, srcLMS);
      const LMS = mul3x3v(M, XYZ);
      const LMSa = mulVec(LMS, scale);
      return mul3x3v(Minv, LMSa);
    }
    // Lab -> XYZ (for given white)
    function labToXyz(L, a, b, whiteXYZ){
      const fy = (L + 16) / 116;
      const fx = fy + a / 500;
      const fz = fy - b / 200;
      const epsilon = 216/24389;
      const kappa   = 24389/27;
      const fx3 = fx*fx*fx, fy3 = fy*fy*fy, fz3 = fz*fz*fz;
      const xr = (fx3 > epsilon) ? fx3 : (116*fx - 16)/kappa;
      const yr = (L > kappa*epsilon) ? Math.pow((L+16)/116, 3) : L/kappa;
      const zr = (fz3 > epsilon) ? fz3 : (116*fz - 16)/kappa;
      return [xr*whiteXYZ[0], yr*whiteXYZ[1], zr*whiteXYZ[2]];
    }
    // XYZ (D65) -> linear sRGB, then compand
    function xyzD65ToLinSrgb(X,Y,Z){
      const r =  3.2406*X/100 + (-1.5372)*Y/100 + (-0.4986)*Z/100;
      const g = -0.9689*X/100 +  1.8758*Y/100 +  0.0415*Z/100;
      const b =  0.0557*X/100 + (-0.2040)*Y/100 +  1.0570*Z/100;
      return [r,g,b];
    }
    function lin2srgb(u){
      return (u <= 0.0031308) ? 12.92*u : 1.055*Math.pow(u, 1/2.4) - 0.055;
    }
    function inGamut(rgb){
      return rgb[0]>=0 && rgb[1]>=0 && rgb[2]>=0 && rgb[0]<=1 && rgb[1]<=1 && rgb[2]<=1;
    }
    // Try to preserve hue by reducing chroma until inside gamut
    function labToDisplaySRGB(L, a, b, whiteTag="D65_2"){
      const srcWP = WP[whiteTag];
      let XYZ = labToXyz(L, a, b, srcWP);
      const XYZd65 = (whiteTag.startsWith("D65")) ? XYZ : bradfordAdaptXYZ(XYZ, srcWP, WP.D65_2);
      let lin = xyzD65ToLinSrgb(...XYZd65);
      if(!inGamut(lin)){
        let lo=0, hi=1;
        for(let i=0;i<16;i++){
          const t = (lo+hi)/2;
          const XYZt = labToXyz(L, a*t, b*t, srcWP);
          const XYZd = (whiteTag.startsWith("D65")) ? XYZt : bradfordAdaptXYZ(XYZt, srcWP, WP.D65_2);
          const lint = xyzD65ToLinSrgb(...XYZd);
          if(inGamut(lint)){ lin=lint; lo=t; } else { hi=t; }
        }
      }
      return lin.map(lin2srgb).map(v => Math.round(255*Math.min(1,Math.max(0,v))));
    }
    // Draw a*b* slice at fixed L*
    function drawLabABPlane(canvas, Lstar=70, aMin=-160, aMax=160, bMin=-160, bMax=160, whiteTag="D65_2"){
      const ctx = canvas.getContext('2d', { willReadFrequently: false });
      const {width:w, height:h} = canvas;
      const img = ctx.createImageData(w,h);
      const data = img.data;
      for(let y=0; y<h; y++){
        const b = bMax + (bMin - bMax) * (y/(h-1));
        for(let x=0; x<w; x++){
          const a = aMin + (aMax - aMin) * (x/(w-1));
          const [R,G,B] = labToDisplaySRGB(Lstar, a, b, whiteTag);
          const idx = 4*(y*w + x);
          data[idx]   = R;
          data[idx+1] = G;
          data[idx+2] = B;
          data[idx+3] = 255;
        }
      }
      ctx.putImageData(img, 0, 0);
    }
    // Convert Lab directly to sRGB array (0â€“1)
    function labToSRGB(lab, whiteTag="D65_2") {
      const rgb = labToDisplaySRGB(lab.L, lab.a, lab.b, whiteTag);
      return rgb.map(v => v/255);
    }
    // Convert sRGB array to CSS hex string
    function srgbToHex(rgb) {
      const toHex = v => {
        const h = Math.round(v*255);
        return h.toString(16).padStart(2,'0');
      };
      const [r,g,b] = rgb;
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }
    function idealTextColor(hex) {
      const r = parseInt(hex.slice(1,3),16);
      const g = parseInt(hex.slice(3,5),16);
      const b = parseInt(hex.slice(5,7),16);
      const lum = 0.299*r + 0.587*g + 0.114*b;
      return lum > 186 ? '#000' : '#fff';
    }
    // Approximate mapping from wavelength (nm) to sRGB. Only defined for 400â€“700 nm.
    function wavelengthToSRGB(nm) {
      let r=0, g=0, b=0;
      if (nm >= 380 && nm < 440) {
        r = -(nm - 440) / (440 - 380);
        g = 0.0;
        b = 1.0;
      } else if (nm >= 440 && nm < 490) {
        r = 0.0;
        g = (nm - 440) / (490 - 440);
        b = 1.0;
      } else if (nm >= 490 && nm < 510) {
        r = 0.0;
        g = 1.0;
        b = -(nm - 510) / (510 - 490);
      } else if (nm >= 510 && nm < 580) {
        r = (nm - 510) / (580 - 510);
        g = 1.0;
        b = 0.0;
      } else if (nm >= 580 && nm < 645) {
        r = 1.0;
        g = -(nm - 645) / (645 - 580);
        b = 0.0;
      } else if (nm >= 645 && nm <= 780) {
        r = 1.0;
        g = 0.0;
        b = 0.0;
      }
      // intensity factor (fade near edges)
      let factor;
      if (nm >= 380 && nm < 420) {
        factor = 0.3 + 0.7 * (nm - 380) / (420 - 380);
      } else if (nm >= 420 && nm < 645) {
        factor = 1.0;
      } else if (nm >= 645 && nm <= 780) {
        factor = 0.3 + 0.7 * (780 - nm) / (780 - 645);
      } else {
        factor = 0.0;
      }
      const gamma = 0.8;
      const conv = c => Math.pow(c * factor, gamma);
      return [conv(r), conv(g), conv(b)];
    }

    // ------------------------------------------------------------------
    // Colour gradient definitions for the scales
    // Each entry defines a list of stops for a particular scale. The
    // `value` field corresponds to the scale reading and `color` is the
    // approximate colour for that position on the scale. These gradients
    // are used to render a continuous colour bar behind the axis, even
    // when no samples are loaded. Colours have been handâ€‘picked to
    // approximate commonly used scale charts: light values near 0 and
    // progressively darker, more saturated tones towards the upper end.
    const scaleGradientStops = {
      // ASTM D1500 colour scale approximated from reference chart.  Values
      // progress from pale yellow through orange and red to near black.
      // The image provided shows discrete steps at halfâ€‘unit increments; we
      // interpolate between a broader set of anchor points to give a smooth
      // gradient. See userâ€‘supplied chart for target colours.
      'ASTM D1500': [
        { value: 0,   color: '#fff9c4' }, // very pale yellow
        { value: 1,   color: '#ffe173' }, // light golden
        { value: 2,   color: '#ffb100' }, // orange
        { value: 3,   color: '#ff7f24' }, // redâ€‘orange
        { value: 4,   color: '#c02928' }, // deep red
        { value: 5,   color: '#7a0d1d' }, // dark maroon
        { value: 6,   color: '#36050b' }, // almost black
        { value: 8,   color: '#000000' }, // black
      ],
      // Saybolt colour scale is essentially a very pale yellow that
      // becomes even lighter towards higher positive values.  The values
      // below are sampled from the provided illustration.  The left end
      // (value +30) is nearly white; the right end (value âˆ’16) is a
      // slightly more saturated yellow.
      'Saybolt': [
        { value: -16, color: '#fdf5c0' }, // pale yellow at low values
        { value: 0,   color: '#fffbe8' }, // almost colourless
        { value: 30,  color: '#ffffff' }, // clear/white
      ],
      // Ptâ€‘Co (Hazen/APHA) scale runs from clear through light ivory to pale
      // yellow.  These stops are chosen to approximate the reference image.
      'Pt-Co (Hazen)': [
        { value: 0,   color: '#ffffff' }, // clear water
        { value: 250, color: '#fff7d5' }, // light ivory/yellow
        { value: 500, color: '#f7e48b' }, // pale yellow
      ],
    };
    // CSV parser
    function parseCSV(text) {
      const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
      if (lines.length === 0) return {samples: [], warnings: []};
      const headerLine = lines[0];
      // Determine separator: comma or semicolon by counting
      const countComma = (headerLine.match(/,/g) || []).length;
      const countSemi  = (headerLine.match(/;/g) || []).length;
      const sep = countSemi > countComma ? ';' : ',';
      const header = headerLine.split(sep).map(h => h.trim());
      const samples = [];
      const warnings = [];
      for (let i=1; i<lines.length; i++) {
        const row = lines[i];
        if (!row || /^\s*$/.test(row)) continue;
        // Skip duplicate header lines if the first three columns match 'No.', 'Name', 'Date'
        const maybeHeader = row.split(sep);
        if (maybeHeader.length >= 3) {
          const h0 = maybeHeader[0].trim();
          const h1 = maybeHeader[1].trim();
          const h2 = maybeHeader[2].trim();
          if (h0 === 'No.' && h1 === 'Name' && h2 === 'Date') {
            continue;
          }
        }
        // Determine decimal separator for this line: if values have commas not due to separator
        // heuristically check numeric fields
        let decSep = '.';
        // check if there is a comma in number section (not as field separator)
        const numericParts = row.split(sep).slice(7);
        for (const part of numericParts) {
          if (part && part.trim().match(/\d,\d/)) { decSep = ','; break; }
        }
        const cols = row.split(sep);
        if (cols.length < header.length) {
          warnings.push(`Line ${i+1}: expected ${header.length} columns, got ${cols.length}`);
        }
        const obj = {};
        for (let j=0; j<header.length; j++) {
          const key = header[j];
          const val = cols[j] || '';
          if (/^\d{3}nm\(A\)$/i.test(key)) {
            // Spectral columns will be added after loop
            continue;
          }
          if (['L*','a*','b*','Hazen(APHA)','Gardner','Saybolt','ASTM','Pt-Co'].includes(key)) {
            obj[key] = sanitizeNumber(val, decSep);
          } else {
            obj[key] = val.trim();
          }
        }
        // Add spectrum: key-value pairs of wavelength to absorbance
        const spectrum = [];
        header.forEach((h, idx) => {
          const match = h.match(/^(\d{3})nm\(A\)$/);
          if (match) {
            const nm = parseInt(match[1]);
            const v = cols[idx];
            spectrum.push({
              wavelength: nm,
              absorbance: sanitizeSpectrumNumber(v, decSep, SATURATION_LIMIT)
            });
          }
        });
        spectrum.sort((a,b) => a.wavelength - b.wavelength);
        obj.spectrum = spectrum;
        // Precompute derived values
        obj.Cstar = isFinite(obj['a*']) && isFinite(obj['b*']) ? Math.hypot(obj['a*'], obj['b*']) : NaN;
        obj.hueDeg = isFinite(obj['a*']) && isFinite(obj['b*']) ? ((Math.atan2(obj['b*'], obj['a*'])*180/Math.PI+360)%360) : NaN;
        // Compute sRGB and hex colour from Lab values if valid
        if (isFinite(obj['L*']) && isFinite(obj['a*']) && isFinite(obj['b*'])) {
          const rgb = labToSRGB({L: obj['L*'], a: obj['a*'], b: obj['b*']});
          obj.srgb = rgb;
          obj.hex = srgbToHex(rgb);
        } else {
          obj.srgb = null;
          obj.hex = null;
        }
        // Create unique id for sample to avoid collisions
        obj.id = `${obj['No.']}||${obj['Name']}`;
        samples.push(obj);
      }
      return {samples, warnings};
    }
    // Render functions
    function updateIlluminantOptions() {
      const select = document.getElementById('illuminantFilter');
      const unique = new Set(state.samples.map(s => s.Illuminant).filter(Boolean));
      const prev = state.illuminantFilter;
      select.innerHTML = '<option value="">' + t('all') + '</option>';
      unique.forEach(val => {
        const opt = document.createElement('option');
        opt.value = val;
        opt.textContent = val;
        if (val === prev) opt.selected = true;
        select.appendChild(opt);
      });
    }
    function filteredSamples() {
      return state.samples.filter(s => {
        if (state.illuminantFilter && s.Illuminant !== state.illuminantFilter) return false;
        const search = state.search.toLowerCase();
        if (search) {
          const target = `${s['No.']} ${s.Name}`.toLowerCase();
          if (!target.includes(search)) return false;
        }
        if (state.hideUnselected && !state.selected.has(s.id)) return false;
        return true;
      });
    }
    function updateTable() {
      const tbody = document.querySelector('#samples-table tbody');
      tbody.innerHTML = '';
      const rows = filteredSamples();
      rows.forEach(sample => {
        const tr = document.createElement('tr');
        // checkbox
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = state.selected.has(sample.id);
        cb.addEventListener('change', () => {
          if (cb.checked) {
            state.selected.add(sample.id);
            if (!state.selectedOrder.includes(sample.id)) state.selectedOrder.push(sample.id);
          } else {
            state.selected.delete(sample.id);
            state.selectedOrder = state.selectedOrder.filter(id => id !== sample.id);
          }
          persistState();
          scheduleDraw();
        });
        const tdCb = document.createElement('td');
        tdCb.appendChild(cb);
        tr.appendChild(tdCb);
        if (!sample.color) sample.color = COLOR_OPTIONS[0];
        const colorSel = document.createElement('select');
        COLOR_OPTIONS.forEach((col, idx) => {
          const opt = document.createElement('option');
          opt.value = col;
          opt.textContent = idx + 1;
          opt.style.backgroundColor = col;
          opt.style.color = idealTextColor(col);
          colorSel.appendChild(opt);
        });
        colorSel.value = sample.color;
        colorSel.style.backgroundColor = sample.color;
        colorSel.style.color = idealTextColor(sample.color);
        colorSel.addEventListener('change', () => {
          sample.color = colorSel.value;
          colorSel.style.backgroundColor = sample.color;
          colorSel.style.color = idealTextColor(sample.color);
          scheduleDraw();
        });
        const tdColor = document.createElement('td');
        tdColor.appendChild(colorSel);
        tr.appendChild(tdColor);
        [ 'No.', 'Name', 'Date', 'Time', 'Average', 'Illuminant', 'L*', 'a*', 'b*', 'Hazen(APHA)', 'Gardner', 'Saybolt', 'ASTM', 'Pt-Co' ].forEach(key => {
          const td = document.createElement('td');
          const val = sample[key];
          // Make the Name field editable so users can rename samples. When
          // edited, update the sample objectâ€™s name and id accordingly. If
          // the sample was selected or last clicked, update those ids as well.
          if (key === 'Name') {
            const span = document.createElement('span');
            span.contentEditable = true;
            span.textContent = val;
            span.addEventListener('keydown', e => {
              // Commit changes on Enter; prevent newline insertion
              if (e.key === 'Enter') {
                e.preventDefault();
                span.blur();
              }
            });
            span.addEventListener('blur', e => {
              const newName = span.textContent.trim();
              if (newName && newName !== sample['Name']) {
                const oldId = sample.id;
                sample['Name'] = newName;
                sample.id = `${sample['No.']}||${newName}`;
                // Update selected set if necessary
                if (state.selected.has(oldId)) {
                  state.selected.delete(oldId);
                  state.selected.add(sample.id);
                }
                const idx = state.selectedOrder.indexOf(oldId);
                if (idx !== -1) state.selectedOrder[idx] = sample.id;
                // Update last clicked id
                if (state.lastClicked === oldId) {
                  state.lastClicked = sample.id;
                }
                // Re-render table and charts to reflect new name
                updateTable();
                scheduleDraw();
                drawDetails();
              }
            });
            td.appendChild(span);
          } else {
            let text = '';
            if (key === 'L*' || key === 'a*' || key === 'b*') text = isFinite(val) ? val.toFixed(2) : '';
            else if (['Hazen(APHA)','Gardner','Saybolt','ASTM','Pt-Co'].includes(key)) text = isFinite(val) ? val.toFixed(1) : '';
            else text = val;
            td.textContent = text;
          }
          tr.appendChild(td);
        });
        tr.addEventListener('click', (ev) => {
          // If clicking on checkbox skip
          if (ev.target.tagName.toLowerCase() === 'input') return;
          state.lastClicked = sample.id;
          drawDetails();
        });
        tbody.appendChild(tr);
      });
      // Update selectAll state
      const selectAllCb = document.getElementById('selectAll');
      const allShownIds = rows.map(s => s.id);
      const allSelected = allShownIds.length > 0 && allShownIds.every(id => state.selected.has(id));
      selectAllCb.checked = allSelected;
    }
    function updateWarning(warnings) {
      const warnDiv = document.getElementById('warning');
      if (warnings && warnings.length) {
        warnDiv.textContent = warnings.join('; ');
        warnDiv.style.display = 'block';
      } else {
        warnDiv.style.display = 'none';
      }
    }
    // Chart drawing helpers
    function clearSVG(svg) {
      while (svg.firstChild) svg.removeChild(svg.firstChild);
    }
    function createSVG(width, height) {
      const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      return svg;
    }
    function drawScales() {
      const svg = document.getElementById('scalesChart');
      clearSVG(svg);
      const width = svg.clientWidth;
      const height = svg.clientHeight;
      const padding = {top:20,right:40,bottom:30,left:40};
      const chartHeight = (height - padding.top - padding.bottom) / 3;
      const fontSize = parseFloat(getComputedStyle(document.body).fontSize);
      const titleSize = fontSize * 1.2;
      // Set up a defs container for gradients
      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      svg.appendChild(defs);
      const scales = [
        // ASTM D1500 scale ranges from 0 to 8. Gardner is no longer used.
        {name:'ASTM D1500', min:0, max:8, step:1, valKey:'ASTM'},
        {name:'Saybolt', min:-16, max:30, step:2, valKey:'Saybolt'},
        {name:'Pt-Co (Hazen)', min:0, max:500, step:50, valKey:'Pt-Co'},
      ];
      scales.forEach((sc, idx) => {
        const y0 = padding.top + idx*chartHeight;
        // Define a gradient for the current scale using our precomputed stops
        const gradId = `scaleGrad_${idx}`;
        const gradient = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
        gradient.setAttribute('id', gradId);
        gradient.setAttribute('x1','0%');
        gradient.setAttribute('y1','0%');
        gradient.setAttribute('x2','100%');
        gradient.setAttribute('y2','0%');
        const stops = scaleGradientStops[sc.name] || [];
        stops.forEach(stop => {
          // normalise the stop position relative to the scale range
          const off = (stop.value - sc.min) / (sc.max - sc.min);
          const pos = Math.max(0, Math.min(1, off));
          const stopEl = document.createElementNS('http://www.w3.org/2000/svg','stop');
          stopEl.setAttribute('offset', (pos*100) + '%');
          stopEl.setAttribute('stop-color', stop.color);
          gradient.appendChild(stopEl);
        });
        defs.appendChild(gradient);
        // Draw the colour bar. Increase thickness relative to the original
        // design to better fill the available vertical space at 125% zoom.
        // A 30px height gives clear delineation of the gradient without
        // overwhelming the axis.
        const barHeight = 30;
        const barY = y0 + chartHeight/2 - barHeight/2;
        const bar = document.createElementNS('http://www.w3.org/2000/svg','rect');
        bar.setAttribute('x', padding.left);
        bar.setAttribute('y', barY);
        bar.setAttribute('width', width - padding.left - padding.right);
        bar.setAttribute('height', barHeight);
        bar.setAttribute('fill', `url(#${gradId})`);
        svg.appendChild(bar);
        // axis line positioned below the colour bar so that ticks and
        // labels remain legible against the background colours
        const axisY = barY + barHeight + 6;
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', padding.left);
        line.setAttribute('x2', width - padding.right);
        line.setAttribute('y1', axisY);
        line.setAttribute('y2', axisY);
        line.setAttribute('stroke', 'currentColor');
        svg.appendChild(line);
        // ticks and numeric labels beneath the bar
        for (let v=sc.min; v<=sc.max; v+=sc.step) {
          const x = padding.left + (v - sc.min)/(sc.max - sc.min) * (width - padding.left - padding.right);
          const tick = document.createElementNS('http://www.w3.org/2000/svg','line');
          tick.setAttribute('x1', x);
          tick.setAttribute('x2', x);
          tick.setAttribute('y1', axisY);
          tick.setAttribute('y2', axisY - 6);
          tick.setAttribute('stroke', 'currentColor');
          svg.appendChild(tick);
          const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
          lbl.setAttribute('x', x);
          lbl.setAttribute('y', axisY + 16);
          lbl.setAttribute('text-anchor', 'middle');
          lbl.setAttribute('font-size', fontSize);
          lbl.textContent = v;
          svg.appendChild(lbl);
        }
        // title
        const title = document.createElementNS('http://www.w3.org/2000/svg','text');
        title.setAttribute('x', padding.left);
        title.setAttribute('y', y0 + 16);
        title.setAttribute('font-size', titleSize);
        title.setAttribute('font-weight','bold');
        title.textContent = sc.name;
        svg.appendChild(title);
        // markers for selected samples
        const selectedList = filteredSamples().filter(s => state.selected.has(s.id));
        selectedList.forEach(sample => {
          const val = sample[sc.valKey];
          const altVal = sc.altKey ? sample[sc.altKey] : undefined;
          if (!isFinite(val) && !isFinite(altVal)) return;
          const usedVal = isFinite(val) ? val : altVal;
          // project the value onto the bar
          const x = padding.left + (usedVal - sc.min)/(sc.max - sc.min) * (width - padding.left - padding.right);
          const y = y0 + chartHeight/2;
          const size = 6;
          // triangle marker using palette colour
          const tri = document.createElementNS('http://www.w3.org/2000/svg','polygon');
          tri.setAttribute('points', `${x},${y-size} ${x-size},${y+size} ${x+size},${y+size}`);
          tri.setAttribute('fill', getSampleColor(sample));
          tri.addEventListener('mousemove', evt => {
            const tooltipLines = [];
            tooltipLines.push(sample['Name']);
            tooltipLines.push(`${sc.name}: ${isFinite(usedVal) ? usedVal.toFixed(1) : ''}`);
            tooltipLines.push(`${sample['Date']} ${sample['Time']}`);
            if (isFinite(sample['L*']) && isFinite(sample['a*']) && isFinite(sample['b*'])) {
              tooltipLines.push(`L*: ${sample['L*'].toFixed(2)}  a*: ${sample['a*'].toFixed(2)}  b*: ${sample['b*'].toFixed(2)}`);
            }
            showTooltip(evt.clientX, evt.clientY, tooltipLines.join('\n'));
          });
          tri.addEventListener('mouseleave', hideTooltip);
          svg.appendChild(tri);
          // marker only; labels removed
        });
      });
    }
    function drawAB() {
      const svg = document.getElementById('abChart');
      clearSVG(svg);
      const width = svg.clientWidth;
      const height = svg.clientHeight;
      const padding = 40;
      const originX = width/2;
      const originY = height/2;
      const maxRadius = Math.min(width, height)/2 - padding;
      const fontSize = parseFloat(getComputedStyle(document.body).fontSize);
      // The AB plane now covers values from -140 to +140 instead of Â±100.
      const AB_RANGE = 140;
      // Clip path for circular region
      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      const clip = document.createElementNS('http://www.w3.org/2000/svg','clipPath');
      const clipId = 'abClip';
      clip.setAttribute('id', clipId);
      // Specify clipPathUnits to ensure correct dimensions when exporting. Without
      // this attribute the clipping may fail in the exported PNG.
      clip.setAttribute('clipPathUnits','userSpaceOnUse');
      const clipCircle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      clipCircle.setAttribute('cx', originX);
      clipCircle.setAttribute('cy', originY);
      clipCircle.setAttribute('r', maxRadius);
      clip.appendChild(clipCircle);
      defs.appendChild(clip);
      svg.appendChild(defs);
      // Group for all elements that should be clipped to the circle
      const plotGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
      plotGroup.setAttribute('clip-path', `url(#${clipId})`);
      svg.appendChild(plotGroup);
      // Draw a colour map within the circle representing mixtures of a* and b*.
      // Generate a canvas using true CIELABâ†’sRGB conversion and embed it as an image.
      (function() {
        const res = 200; // resolution of the colour map grid
        const canvas = document.createElement('canvas');
        canvas.width = res;
        canvas.height = res;
        drawLabABPlane(canvas, 70, -AB_RANGE, AB_RANGE, -AB_RANGE, AB_RANGE, 'D65_2');
        const url = canvas.toDataURL();
        const imgEl = document.createElementNS('http://www.w3.org/2000/svg', 'image');
        imgEl.setAttributeNS('http://www.w3.org/1999/xlink', 'href', url);
        imgEl.setAttribute('x', 0);
        imgEl.setAttribute('y', 0);
        imgEl.setAttribute('width', width);
        imgEl.setAttribute('height', height);
        // Prepend the image so it sits beneath rings and points
        plotGroup.appendChild(imgEl);
      })();
      // draw concentric circles for C* (20/40/60/80/100/120/140) scaled to Â±140
      const rings = [20,40,60,80,100,120,140];
      rings.forEach(rVal => {
        const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
        const rad = (rVal / AB_RANGE) * maxRadius;
        circ.setAttribute('cx', originX);
        circ.setAttribute('cy', originY);
        circ.setAttribute('r', rad);
        circ.setAttribute('fill','none');
        circ.setAttribute('stroke','var(--border)');
        circ.setAttribute('stroke-dasharray','2 2');
        plotGroup.appendChild(circ);
      });
      // axes: draw them on the main svg, not inside the clipped group, so
      // they appear across the full chart.  Without this change the
      // axes were clipped out of exported images.
      const axisXLine = document.createElementNS('http://www.w3.org/2000/svg','line');
      axisXLine.setAttribute('x1', padding);
      axisXLine.setAttribute('x2', width - padding);
      axisXLine.setAttribute('y1', originY);
      axisXLine.setAttribute('y2', originY);
      axisXLine.setAttribute('stroke','var(--border)');
      svg.appendChild(axisXLine);
      const axisYLine = document.createElementNS('http://www.w3.org/2000/svg','line');
      axisYLine.setAttribute('x1', originX);
      axisYLine.setAttribute('x2', originX);
      axisYLine.setAttribute('y1', padding);
      axisYLine.setAttribute('y2', height - padding);
      axisYLine.setAttribute('stroke','var(--border)');
      svg.appendChild(axisYLine);
      // grid lines every 10 units
      // grid lines every 20 units across the Â±140 range
      for (let v=-140; v<=140; v+=20) {
        const x = originX + (v / AB_RANGE) * maxRadius;
        const y = originY - (v / AB_RANGE) * maxRadius;
        // vertical grid
        const vg = document.createElementNS('http://www.w3.org/2000/svg','line');
        vg.setAttribute('x1', x);
        vg.setAttribute('x2', x);
        vg.setAttribute('y1', padding);
        vg.setAttribute('y2', height - padding);
        vg.setAttribute('stroke','var(--border)');
        vg.setAttribute('stroke-dasharray','2 2');
        plotGroup.appendChild(vg);
        // horizontal grid
        const hg = document.createElementNS('http://www.w3.org/2000/svg','line');
        hg.setAttribute('y1', y);
        hg.setAttribute('y2', y);
        hg.setAttribute('x1', padding);
        hg.setAttribute('x2', width - padding);
        hg.setAttribute('stroke','var(--border)');
        hg.setAttribute('stroke-dasharray','2 2');
        plotGroup.appendChild(hg);
        // labels for axes (not clipped, attach to main svg)
        if (v !== 0) {
          const lblX = document.createElementNS('http://www.w3.org/2000/svg','text');
          lblX.setAttribute('x', x);
          lblX.setAttribute('y', originY + 16);
          lblX.setAttribute('font-size', fontSize);
          lblX.setAttribute('text-anchor','middle');
          lblX.textContent = v;
          svg.appendChild(lblX);
          const lblY = document.createElementNS('http://www.w3.org/2000/svg','text');
          lblY.setAttribute('x', originX - 3);
          lblY.setAttribute('y', y + 5);
          lblY.setAttribute('font-size', fontSize);
          lblY.setAttribute('text-anchor','end');
          lblY.textContent = v;
          svg.appendChild(lblY);
        }
      }
      // plot selected samples
      const selectedAB = filteredSamples().filter(s => state.selected.has(s.id));
      selectedAB.forEach(sample => {
        const a = sample['a*'];
        const b = sample['b*'];
        if (!isFinite(a) || !isFinite(b)) return;
        const x = originX + (a / AB_RANGE) * maxRadius;
        const y = originY - (b / AB_RANGE) * maxRadius;
        const size = 5;
        const tri = document.createElementNS('http://www.w3.org/2000/svg','polygon');
        tri.setAttribute('points', `${x},${y-size} ${x-size},${y+size} ${x+size},${y+size}`);
        // fill using palette colour to match other charts
        tri.setAttribute('fill', getSampleColor(sample));
        tri.setAttribute('stroke', 'currentColor');
        tri.setAttribute('stroke-width', '0.5');
        tri.addEventListener('mousemove', evt => {
          const lines = [];
          lines.push(sample['Name']);
          if (isFinite(sample['L*']) && isFinite(sample['a*']) && isFinite(sample['b*'])) {
            lines.push(`L*: ${sample['L*'].toFixed(2)}  a*: ${sample['a*'].toFixed(2)}  b*: ${sample['b*'].toFixed(2)}`);
          }
          showTooltip(evt.clientX, evt.clientY, lines.join('\n'));
        });
        tri.addEventListener('mouseleave', hideTooltip);
        plotGroup.appendChild(tri);
        // marker only; labels removed
      });

    }
    function drawL() {
      const svg = document.getElementById('lChart');
      clearSVG(svg);
      const width = svg.clientWidth;
      const height = svg.clientHeight;
      const padding = {top:20,right:20,bottom:20,left:30};
      const fontSize = parseFloat(getComputedStyle(document.body).fontSize);
      // vertical axis spans 0â€“100. Draw a vertical gradient next to the axis
      // to visually indicate the progression from light (top) to dark
      // (bottom). Ticks and labels are drawn on the axis. The axis
      // markers extend to the right of the gradient.
      const axisX = padding.left;
      const y0 = padding.top;
      const y1 = height - padding.bottom;
      // Create gradient definition
      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      const gradId = 'lGrad_' + Math.random().toString(36).slice(2);
      const gradient = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
      gradient.setAttribute('id', gradId);
      gradient.setAttribute('x1','0%');
      gradient.setAttribute('y1','0%');
      gradient.setAttribute('x2','0%');
      gradient.setAttribute('y2','100%');
      const stopTop = document.createElementNS('http://www.w3.org/2000/svg','stop');
      stopTop.setAttribute('offset','0%');
      stopTop.setAttribute('stop-color','#ffffff');
      gradient.appendChild(stopTop);
      const stopBottom = document.createElementNS('http://www.w3.org/2000/svg','stop');
      stopBottom.setAttribute('offset','100%');
      stopBottom.setAttribute('stop-color','#000000');
      gradient.appendChild(stopBottom);
      defs.appendChild(gradient);
      svg.appendChild(defs);
      // Draw gradient bar. Position it just to the right of the axis line.
      const barWidth = 12;
      const gradRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
      gradRect.setAttribute('x', axisX + 8);
      gradRect.setAttribute('y', y0);
      gradRect.setAttribute('width', barWidth);
      gradRect.setAttribute('height', y1 - y0);
      gradRect.setAttribute('fill', `url(#${gradId})`);
      svg.appendChild(gradRect);
      // axis line
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', axisX);
      line.setAttribute('x2', axisX);
      line.setAttribute('y1', y0);
      line.setAttribute('y2', y1);
      line.setAttribute('stroke','currentColor');
      svg.appendChild(line);
      // ticks and labels every 10 units
      for (let v=0; v<=100; v+=10) {
        const y = y1 - (v/100)*(y1 - y0);
        const tick = document.createElementNS('http://www.w3.org/2000/svg','line');
        tick.setAttribute('x1', axisX - 4);
        tick.setAttribute('x2', axisX + 4);
        tick.setAttribute('y1', y);
        tick.setAttribute('y2', y);
        tick.setAttribute('stroke','currentColor');
        svg.appendChild(tick);
        const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
        lbl.setAttribute('x', axisX - 6);
        lbl.setAttribute('y', y + 5);
        lbl.setAttribute('font-size', fontSize);
        lbl.setAttribute('text-anchor','end');
        lbl.textContent = v;
        svg.appendChild(lbl);
      }
      // markers for each selected sample
      const selectedL = filteredSamples().filter(s => state.selected.has(s.id));
      selectedL.forEach(sample => {
        const l = sample['L*'];
        if (!isFinite(l)) return;
        const yPos = y1 - (l/100)*(y1 - y0);
        const size = 5;
        const markerX = axisX + barWidth + 10;
        const tri = document.createElementNS('http://www.w3.org/2000/svg','polygon');
        tri.setAttribute('points', `${markerX},${yPos} ${markerX+size},${yPos-size} ${markerX+size},${yPos+size}`);
        // fill using palette colour to match other charts
        tri.setAttribute('fill', getSampleColor(sample));
        tri.setAttribute('stroke','currentColor');
        tri.setAttribute('stroke-width','0.5');
        tri.addEventListener('mousemove', evt => {
          showTooltip(evt.clientX, evt.clientY, `${sample['Name']}\nL*: ${l.toFixed(2)}`);
        });
        tri.addEventListener('mouseleave', hideTooltip);
        svg.appendChild(tri);
        // marker only; labels removed
      });
    }
    function drawSpectrum() {
      const svg = document.getElementById('spectrumChart');
      clearSVG(svg);
      const width = svg.clientWidth;
      const height = svg.clientHeight;
      // Extra bottom space for the wavelength color band and its label
      const bandHeight = 18;
      // Increase top padding to prevent curves from touching the top of the viewport
      const padding = {top:30,right:60,bottom:50 + bandHeight,left:90};
      const fontSize = parseFloat(getComputedStyle(document.body).fontSize);
      const titleSize = fontSize * 1.2;
      const samplesToPlot = filteredSamples().filter(s => state.selected.has(s.id));
      if (samplesToPlot.length === 0) return;
      // Determine x range (wavelength)
      const allWs = samplesToPlot.flatMap(s => s.spectrum.map(p => p.wavelength));
      const minW = Math.min(...allWs);
      const maxW = Math.max(...allWs);
      // Determine y range (absorbance or log)
      const allYs = [];
      samplesToPlot.forEach(s => {
        const values = s.spectrum.map(p => {
          const y = p.absorbance;
          if (!isFinite(y)) return NaN;
          return state.logScale ? Math.log10(y) : y;
        }).filter(v => isFinite(v));
        allYs.push(...values);
      });
      const saturationDisplay = state.logScale ? Math.log10(SATURATION_LIMIT) : SATURATION_LIMIT;
      let maxY = Math.max(...allYs);
      if (!isFinite(maxY)) {
        maxY = saturationDisplay;
      }
      if (state.yMax !== null && isFinite(state.yMax) && state.yMax > 0) {
        maxY = state.yMax;
      } else if (isFinite(saturationDisplay)) {
        maxY = Math.max(maxY, saturationDisplay);
      }
      let minY = 0;
      if (maxY <= minY) {
        maxY = minY + 1;
      }
      const toX = w => padding.left + (w - minW)/(maxW - minW) * (width - padding.left - padding.right);
      const toY = y => padding.top + (maxY - y)/(maxY - minY) * (height - padding.top - padding.bottom);
      // axes
      // x axis
      const xAxis = document.createElementNS('http://www.w3.org/2000/svg','line');
      xAxis.setAttribute('x1', padding.left);
      xAxis.setAttribute('x2', width - padding.right);
      xAxis.setAttribute('y1', height - padding.bottom);
      xAxis.setAttribute('y2', height - padding.bottom);
      xAxis.setAttribute('stroke','currentColor');
      svg.appendChild(xAxis);
      // x ticks (every 20 nm)
      for (let w=Math.ceil(minW/20)*20; w<=maxW; w+=20) {
        const x = toX(w);
        const tick = document.createElementNS('http://www.w3.org/2000/svg','line');
        tick.setAttribute('x1', x);
        tick.setAttribute('x2', x);
        tick.setAttribute('y1', height - padding.bottom);
        tick.setAttribute('y2', height - padding.bottom + 5);
        tick.setAttribute('stroke','currentColor');
        svg.appendChild(tick);
        const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
        lbl.setAttribute('x', x);
        lbl.setAttribute('y', height - padding.bottom + 24);
        lbl.setAttribute('font-size', fontSize);
        lbl.setAttribute('text-anchor','middle');
        lbl.textContent = w;
        svg.appendChild(lbl);
      }
      // y axis
      const yAxis = document.createElementNS('http://www.w3.org/2000/svg','line');
      yAxis.setAttribute('x1', padding.left);
      yAxis.setAttribute('x2', padding.left);
      yAxis.setAttribute('y1', padding.top);
      yAxis.setAttribute('y2', height - padding.bottom);
      yAxis.setAttribute('stroke','currentColor');
      svg.appendChild(yAxis);
      // y ticks
      const yStep = (maxY - minY)/5;
      for (let i=0;i<=5;i++) {
        const yVal = minY + yStep * i;
        const y = toY(yVal);
        const tick = document.createElementNS('http://www.w3.org/2000/svg','line');
        tick.setAttribute('x1', padding.left - 4);
        tick.setAttribute('x2', padding.left);
        tick.setAttribute('y1', y);
        tick.setAttribute('y2', y);
        tick.setAttribute('stroke','currentColor');
        svg.appendChild(tick);
        const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
        lbl.setAttribute('x', padding.left - 6);
        lbl.setAttribute('y', y + 5);
        lbl.setAttribute('font-size', fontSize);
        lbl.setAttribute('text-anchor','end');
        lbl.textContent = (state.logScale ? yVal.toFixed(2) : yVal.toFixed(3));
        svg.appendChild(lbl);
      }
      // y axis label
      const yTitle = document.createElementNS('http://www.w3.org/2000/svg','text');
      const yTitleX = padding.left - 20;
      yTitle.setAttribute('transform', `rotate(-90 ${yTitleX},${(padding.top + height - padding.bottom)/2})`);
      yTitle.setAttribute('x', yTitleX);
      yTitle.setAttribute('y', (padding.top + height - padding.bottom)/2);
      yTitle.setAttribute('font-size', titleSize);
      yTitle.setAttribute('text-anchor','middle');
      yTitle.textContent = state.logScale ? 'log10(A)' : 'Absorbance';
      svg.appendChild(yTitle);

      if (isFinite(saturationDisplay) && saturationDisplay >= minY && saturationDisplay <= maxY) {
        const satY = toY(saturationDisplay);
        const satLine = document.createElementNS('http://www.w3.org/2000/svg','line');
        satLine.setAttribute('x1', padding.left);
        satLine.setAttribute('x2', width - padding.right);
        satLine.setAttribute('y1', satY);
        satLine.setAttribute('y2', satY);
        satLine.setAttribute('stroke', 'var(--warning-fg)');
        satLine.setAttribute('stroke-width', '1.2');
        satLine.setAttribute('stroke-dasharray', '6 4');
        svg.appendChild(satLine);
        const satLabel = document.createElementNS('http://www.w3.org/2000/svg','text');
        satLabel.setAttribute('x', width - padding.right - 4);
        satLabel.setAttribute('y', satY - 6);
        satLabel.setAttribute('font-size', fontSize);
        satLabel.setAttribute('text-anchor','end');
        satLabel.setAttribute('fill','var(--warning-fg)');
        satLabel.textContent = `Saturation limit (${SATURATION_LIMIT.toFixed(1)})`;
        svg.appendChild(satLabel);
      }
      // x axis label
      const xTitle = document.createElementNS('http://www.w3.org/2000/svg','text');
      xTitle.setAttribute('x', (padding.left + width - padding.right)/2);
      xTitle.setAttribute('y', height - bandHeight - 5);
      xTitle.setAttribute('font-size', titleSize);
      xTitle.setAttribute('text-anchor','middle');
      xTitle.textContent = 'Wavelength (nm)';
      svg.appendChild(xTitle);

      // wavelength colour band under the x axis
      // Create gradient definition
      const gradId = `grad_${Date.now().toString(36)}_${Math.floor(Math.random()*1e6)}`;
      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      const grad = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
      grad.setAttribute('id', gradId);
      grad.setAttribute('x1', '0%');
      grad.setAttribute('x2', '100%');
      grad.setAttribute('y1', '0%');
      grad.setAttribute('y2', '0%');
      // create stops for each wavelength from minW to maxW at 10 nm increments
      const wlStart = Math.ceil(minW / 10) * 10;
      const wlEnd = Math.floor(maxW / 10) * 10;
      // number of 10 nm steps (ensure at least one)
      const totalSteps = Math.max(1, Math.floor((wlEnd - wlStart) / 10));
      const range = wlEnd - wlStart;
      for (let i=0; i<= totalSteps; i++) {
        const wl = wlStart + i*10;
        const offset = range !== 0 ? ((wl - wlStart) / range) * 100 : 0;
        const rgb = wavelengthToSRGB(wl);
        const hex = srgbToHex(rgb);
        const stop = document.createElementNS('http://www.w3.org/2000/svg','stop');
        stop.setAttribute('offset', `${offset}%`);
        stop.setAttribute('stop-color', hex);
        grad.appendChild(stop);
      }
      defs.appendChild(grad);
      svg.appendChild(defs);
      // Draw the band
      const bandX = padding.left;
      const bandY = height - bandHeight;
      const bandW = width - padding.left - padding.right;
      const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
      rect.setAttribute('x', bandX);
      rect.setAttribute('y', bandY);
      rect.setAttribute('width', bandW);
      rect.setAttribute('height', bandHeight);
      rect.setAttribute('fill', `url(#${gradId})`);
      svg.appendChild(rect);
      // label for colour band
      const bandLabel = document.createElementNS('http://www.w3.org/2000/svg','text');
      bandLabel.setAttribute('x', padding.left);
      bandLabel.setAttribute('y', height - bandHeight - 2);
      bandLabel.setAttribute('font-size', fontSize);
      bandLabel.setAttribute('text-anchor','start');
      bandLabel.textContent = 'Absorbed Î» colour';
      svg.appendChild(bandLabel);
      // plots
      samplesToPlot.forEach(sample => {
        let ys = sample.spectrum.map(p => {
          const v = p.absorbance;
          if (!isFinite(v)) return NaN;
          return state.logScale ? Math.log10(v) : v;
        });
        const ws = sample.spectrum.map(p => p.wavelength);
        // optionally smooth
        if (state.smooth && state.smoothWindow > 1) {
          ys = savitzkyGolay(ys, state.smoothWindow);
        }
        const pathParts = [];
        let started = false;
        for (let i=0; i<ws.length; i++) {
          const yVal = ys[i];
          const x = toX(ws[i]);
          const y = toY(yVal);
          if (!isFinite(yVal)) {
            started = false;
            continue;
          }
          if (!started) {
            pathParts.push(`M${x},${y}`);
            started = true;
          } else {
            pathParts.push(`L${x},${y}`);
          }
        }
        const pathEl = document.createElementNS('http://www.w3.org/2000/svg','path');
        pathEl.setAttribute('d', pathParts.join(' '));
        pathEl.setAttribute('fill','none');
        pathEl.setAttribute('stroke', getSampleColor(sample));
        pathEl.setAttribute('stroke-width','1.5');
        pathEl.addEventListener('mousemove', evt => {
          // show wavelength and absorbance near cursor
          const pt = svg.createSVGPoint();
          pt.x = evt.offsetX;
          pt.y = evt.offsetY;
          // invert x to wavelength
          const wEst = minW + ((evt.offsetX - padding.left) / (width - padding.left - padding.right)) * (maxW - minW);
          // find nearest data point
          let idx = 0;
          let minDist = Infinity;
          for (let i=0; i<ws.length; i++) {
            const dx = ws[i] - wEst;
            if (Math.abs(dx) < minDist) { minDist = Math.abs(dx); idx = i; }
          }
          const tooltipVal = state.logScale ? Math.log10(sample.spectrum[idx].absorbance) : sample.spectrum[idx].absorbance;
          showTooltip(evt.clientX, evt.clientY, `${sample['Name']}\n${ws[idx]} nm: ${tooltipVal.toFixed(3)}`);
        });
        pathEl.addEventListener('mouseleave', hideTooltip);
        svg.appendChild(pathEl);
        // area shading
        if (state.shadeArea) {
          const areaPath = [];
          let startedA = false;
          for (let i=0;i<ws.length;i++) {
            const v = ys[i];
            const x = toX(ws[i]);
            const y = toY(v);
            if (!isFinite(v)) {
              if (startedA) {
                areaPath.push(`L${x},${toY(minY)}`);
                areaPath.push('Z');
              }
              startedA = false;
              continue;
            }
            if (!startedA) {
              areaPath.push(`M${x},${toY(minY)}`);
              areaPath.push(`L${x},${y}`);
              startedA = true;
            } else {
              areaPath.push(`L${x},${y}`);
            }
          }
          if (startedA) {
            // close path to baseline
            const lastX = toX(ws[ws.length - 1]);
            areaPath.push(`L${lastX},${toY(minY)}`);
            areaPath.push('Z');
          }
          const areaEl = document.createElementNS('http://www.w3.org/2000/svg','path');
          areaEl.setAttribute('d', areaPath.join(' '));
          areaEl.setAttribute('fill', getSampleColor(sample));
          areaEl.setAttribute('fill-opacity','0.2');
          svg.appendChild(areaEl);
        }

        // labels removed; no text at line end
      });

    }
    function drawCompare() {
      const tbody = document.querySelector('#compare-table tbody');
      if (!tbody) return;
      tbody.innerHTML = '';
      const selectedIds = state.selectedOrder.filter(id => state.selected.has(id));
      if (selectedIds.length === 0) return;
      const samples = selectedIds.map(id => state.samples.find(s => s.id === id)).filter(Boolean);
      if (samples.length === 0) return;
      if (!state.compareRef || !samples.some(s => s.id === state.compareRef)) {
        state.compareRef = samples[0].id;
      }
      const ref = samples.find(s => s.id === state.compareRef);
      samples.forEach(sample => {
        const tr = document.createElement('tr');
        const tdRef = document.createElement('td');
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.name = 'compareRef';
        cb.checked = sample.id === state.compareRef;
        cb.addEventListener('change', () => {
          if (cb.checked) {
            state.compareRef = sample.id;
            tbody.querySelectorAll('input[name="compareRef"]').forEach(el => { if (el !== cb) el.checked = false; });
          } else {
            state.compareRef = samples[0]?.id || null;
          }
          drawCompare();
        });
        tdRef.appendChild(cb);
        tr.appendChild(tdRef);
        ['Name','Date','Time','Illuminant','L*','a*','b*','Hazen(APHA)','Gardner','Saybolt','ASTM','Pt-Co'].forEach(key => {
          const td = document.createElement('td');
          let val = sample[key];
          if (['L*','a*','b*'].includes(key)) val = isFinite(val) ? val.toFixed(2) : '';
          else if (['Hazen(APHA)','Gardner','Saybolt','ASTM','Pt-Co'].includes(key)) val = isFinite(val) ? val.toFixed(1) : '';
          td.textContent = val ?? '';
          tr.appendChild(td);
        });
        const dE = calcDeltaE(sample, ref);
        const tdE = document.createElement('td');
        tdE.textContent = isFinite(dE) ? dE.toFixed(2) : '';
        tr.appendChild(tdE);
        tbody.appendChild(tr);
      });
    }
    function calcDeltaE(s1, s2) {
      if (!s1 || !s2) return NaN;
      const L1 = s1['L*'], a1 = s1['a*'], b1 = s1['b*'];
      const L2 = s2['L*'], a2 = s2['a*'], b2 = s2['b*'];
      if (![L1,a1,b1,L2,a2,b2].every(v => isFinite(v))) return NaN;
      const dL = L1 - L2;
      const da = a1 - a2;
      const db = b1 - b2;
      return Math.hypot(dL, da, db);
    }
    function drawDetails() {
      const div = document.getElementById('detailsCard');
      if (!state.lastClicked) {
        div.textContent = 'No sample selected.';
        return;
      }
      const sample = state.samples.find(s => s.id === state.lastClicked);
      if (!sample) {
        div.textContent = 'No sample selected.';
        return;
      }
      const html = [];
      html.push(`<h2>${sample['Name']}</h2>`);
      html.push(`<p>No.: ${sample['No.']}<br>Date: ${sample['Date']} ${sample['Time']}<br>Average: ${sample['Average']}<br>Illuminant: ${sample['Illuminant']}<br>Attachment: ${sample['Attachment'] || ''}</p>`);
      html.push('<table><thead><tr><th>Scale</th><th>Value</th></tr></thead><tbody>');
      // Only display L*, a*, b* and colour scales; omit C* and hÂ° to simplify details
      [['L*','L*'],['a*','a*'],['b*','b*'],['Hazen','Hazen(APHA)'],['Gardner','Gardner'],['Saybolt','Saybolt'],['ASTM','ASTM'],['Pt-Co','Pt-Co']].forEach(([label,key]) => {
        const v = sample[key];
        if (!isFinite(v)) return;
        const digits = (label === 'Hazen' || label === 'Gardner' || label === 'Saybolt' || label === 'ASTM' || label === 'Pt-Co') ? 1 : 2;
        html.push(`<tr><td>${label}</td><td>${v.toFixed(digits)}</td></tr>`);
      });
      html.push('</tbody></table>');
      // sparkline
      html.push('<svg id="detailSpark" width="100%" height="80"></svg>');
      div.innerHTML = html.join('');
      // draw sparkline
      const spSvg = document.getElementById('detailSpark');
      const w = spSvg.clientWidth;
      const h = spSvg.clientHeight;
      const spPad = {top:5,right:5,bottom:5,left:5};
      const spWs = sample.spectrum.map(p => p.wavelength);
      const spYs = sample.spectrum.map(p => p.absorbance);
      const sminW = Math.min(...spWs);
      const smaxW = Math.max(...spWs);
      const sminY = Math.min(...spYs.filter(v => isFinite(v)));
      const smaxY = Math.max(...spYs.filter(v => isFinite(v)));
      const sx = w => spPad.left + (w - sminW)/(smaxW - sminW) * (w - spPad.left - spPad.right);
      const sy = y => spPad.top + (smaxY - y)/(smaxY - sminY) * (h - spPad.top - spPad.bottom);
      const spPath = [];
      for (let i=0;i<spWs.length;i++) {
        const yVal = spYs[i];
        const x = sx(spWs[i]);
        const y = sy(yVal);
        if (!isFinite(yVal)) {
          continue;
        }
        spPath.push(i===0 ? `M${x},${y}` : `L${x},${y}`);
      }
      const spEl = document.createElementNS('http://www.w3.org/2000/svg','path');
      spEl.setAttribute('d', spPath.join(' '));
      spEl.setAttribute('fill','none');
      spEl.setAttribute('stroke', getSampleColor(sample));
      spEl.setAttribute('stroke-width','1');
      spSvg.appendChild(spEl);

      // After the sparkline, display a compact list of absorbance values.
      // Show only the numeric values (no header) separated by spaces.
      // Values are formatted to three decimals.  Missing values are
      // skipped.
      const values = sample.spectrum.map(p => {
        const y = p.absorbance;
        return isFinite(y) ? y.toFixed(3) : null;
      }).filter(v => v !== null);
      if (values.length) {
        const seriesText = values.join(' ');
        const para = document.createElement('p');
        para.style.marginTop = '0.5rem';
        para.style.fontFamily = 'monospace';
        para.style.fontSize = '0.8rem';
        para.textContent = seriesText;
        div.appendChild(para);
        const copyBtn = document.createElement('button');
        copyBtn.textContent = 'Copy';
        copyBtn.style.marginTop = '0.25rem';
        copyBtn.addEventListener('click', () => navigator.clipboard.writeText(seriesText));
        div.appendChild(copyBtn);
      }
    }
    function getSampleColor(sample) {
      return sample.color || COLOR_OPTIONS[0];
    }
    function getSampleById(id) {
      return state.samples.find(s => s.id === id);
    }
    function beerFindSampleById(id) {
      if (id == null) return null;
      return state.samples.find(s => String(s.id) === String(id)) || null;
    }
    function getSampleLabel(sample) {
      if (!sample) return '';
      return sample['Name'] || sample['No.'] || 'Sample';
    }
    function beerEscapeId(id) {
      const str = String(id);
      if (window.CSS && typeof window.CSS.escape === 'function') {
        return window.CSS.escape(str);
      }
      return str.replace(/[^a-zA-Z0-9_-]/g, s => '\\' + s);
    }
    function cleanupBeerState(validIds) {
      const set = new Set((validIds || []).map(id => String(id)));
      if (state.beerPaths) {
        Object.keys(state.beerPaths).forEach(id => {
          if (!set.has(id)) delete state.beerPaths[id];
        });
      }
      Object.keys(beerState.results).forEach(id => {
        if (!set.has(id)) delete beerState.results[id];
      });
    }
    function extractBeerSpectrum(sample) {
      if (!sample || !Array.isArray(sample.spectrum)) return null;
      const map = new Map();
      sample.spectrum.forEach(point => {
        const wl = Math.round(point.wavelength);
        if (isFinite(point.absorbance)) map.set(wl, point.absorbance);
      });
      const values = [];
      for (const wl of BEER_WAVELENGTHS) {
        if (!map.has(wl)) return null;
        const val = map.get(wl);
        if (!isFinite(val)) return null;
        values.push(val);
      }
      return values;
    }
    function parseBeerPathEntry(entry) {
      const unit = normalizeBeerUnit(entry && entry.unit ? entry.unit : 'mm');
      const original = entry && typeof entry.raw === 'string' ? entry.raw : '';
      const raw = original.trim();
      if (!raw) return { raw: '', unit, meters: null, valid: false };
      const normalized = raw.replace(',', '.');
      const value = parseFloat(normalized);
      if (!isFinite(value) || value <= 0) {
        return { raw, unit, meters: null, valid: false };
      }
      let meters = value;
      if (unit === 'mm') meters = value / 1000;
      else if (unit === 'cm') meters = value / 100;
      else if (unit === 'm') meters = value;
      return { raw, unit, meters, valid: true };
    }
    function renderBeerResultsForSample(sampleId, container) {
      if (!container) {
        container = document.querySelector(`.beer-results[data-sample-id="${beerEscapeId(sampleId)}"]`);
      }
      if (!container) return;
      container.innerHTML = '';
      const entry = ensureBeerEntry(sampleId);
      if (!entry.main.raw || !entry.main.raw.trim()) {
        const msg = document.createElement('div');
        msg.className = 'beer-empty';
        msg.textContent = 'Enter a path length to compute colours.';
        container.appendChild(msg);
        return;
      }
      const result = beerState.results[sampleId];
      if (!result) {
        const msg = document.createElement('div');
        msg.className = 'beer-empty';
        msg.textContent = 'Enter a valid numeric path length to compute colours.';
        container.appendChild(msg);
        return;
      }
      if (result.error) {
        const err = document.createElement('div');
        err.className = 'beer-error';
        err.textContent = result.error;
        container.appendChild(err);
        return;
      }
      const ref = BEER_REFERENCES[result.referenceKey] || BEER_REFERENCES.d65;
      const measurementCount = result.pathDetails ? result.pathDetails.length : 1;
      const summary = document.createElement('div');
      summary.className = 'beer-summary';
      const summaryParts = [`Reference ${ref.label}`, `${measurementCount} path length${measurementCount === 1 ? '' : 's'}`];
      if (result.baselineApplied) summaryParts.push('Baseline correction');
      if (result.clampApplied) summaryParts.push('Negatives clamped');
      summary.textContent = summaryParts.join(' â€¢ ');
      container.appendChild(summary);
      const strip = document.createElement('div');
      strip.className = 'beer-swatch-strip';
      result.colours.forEach(col => {
        const swatch = document.createElement('div');
        swatch.className = 'beer-swatch';
        const [r,g,b] = col.srgb;
        swatch.style.backgroundColor = `rgb(${r},${g},${b})`;
        swatch.style.color = col.Y > 50 ? '#000' : '#fff';
        const hex = '#' + col.srgb.map(v => v.toString(16).padStart(2, '0')).join('').toUpperCase();
        swatch.innerHTML = `<strong>${(col.depth_m * 100).toFixed(0)} cm</strong>L* ${col.L.toFixed(1)}<br>a* ${col.a.toFixed(1)}<br>b* ${col.b.toFixed(1)}<br>Y ${col.Y.toFixed(1)}%<br>${hex}`;
        strip.appendChild(swatch);
      });
      container.appendChild(strip);
      const diag = document.createElement('div');
      diag.className = 'beer-linearity';
      if (result.singlePoint) {
        diag.textContent = 'Linearity diagnostics require at least two path lengths. Assuming Beerâ€“Lambert behaviour.';
        container.appendChild(diag);
      } else if (result.r2) {
        const parts = [];
        Object.keys(result.r2).forEach(key => {
          const value = result.r2[key];
          if (typeof value === 'number' && !isNaN(value)) {
            parts.push(`${key} nm RÂ² ${value.toFixed(3)}`);
          }
        });
        if (parts.length) {
          diag.textContent = `Linearity: ${parts.join(' â€¢ ')}`;
          container.appendChild(diag);
        }
      }
    }
    function computeBeerForSample(sampleId) {
      const entry = ensureBeerEntry(sampleId);
      const parsedMain = parseBeerPathEntry(entry.main);
      if (!parsedMain.valid) {
        if (entry.main.raw && entry.main.raw.trim()) {
          beerState.results[sampleId] = { error: 'Enter a positive numeric path length.' };
        } else {
          delete beerState.results[sampleId];
        }
        renderBeerResultsForSample(sampleId);
        renderBeerCompareTab();
        return;
      }
      const sample = beerFindSampleById(sampleId);
      if (!sample) {
        delete beerState.results[sampleId];
        renderBeerResultsForSample(sampleId);
        renderBeerCompareTab();
        return;
      }
      const measurementData = [];
      const issues = [];
      function addMeasurement(parsed, sampleObj, label) {
        if (!parsed.valid) {
          issues.push(`${label}: enter a positive numeric path length.`);
          return;
        }
        if (!sampleObj) {
          issues.push(`${label}: select a sample with absorbance data.`);
          return;
        }
        const spectrum = extractBeerSpectrum(sampleObj);
        if (!spectrum) {
          issues.push(`${label}: selected sample does not include absorbance for 400â€“700 nm.`);
          return;
        }
        let processed = spectrum.slice();
        let baselineShift = 0;
        if (state.beerBaseline) {
          const tail = [];
          for (let i = 0; i < BEER_WAVELENGTHS.length; i++) {
            if (BEER_WAVELENGTHS[i] >= 650) tail.push(processed[i]);
          }
          baselineShift = beerMedian(tail);
          processed = processed.map(v => v - baselineShift);
        }
        if (state.beerClampNeg) {
          processed = processed.map(v => v < 0 ? 0 : v);
        }
        measurementData.push({
          parsed,
          sampleId: sampleObj.id,
          sampleName: getSampleLabel(sampleObj),
          processed,
          baselineShift,
          label
        });
      }
      addMeasurement(parsedMain, sample, 'Primary');
      entry.extras.forEach((extra, idx) => {
        if (!extra || !extra.enabled) return;
        if (!extra.sourceId) {
          issues.push(`Extra ${idx + 1}: select a sample to supply absorbance data.`);
          return;
        }
        const parsed = parseBeerPathEntry(extra);
        const extraSample = beerFindSampleById(extra.sourceId);
        addMeasurement(parsed, extraSample, `Extra ${idx + 1}`);
      });
      if (issues.length) {
        beerState.results[sampleId] = { error: issues.join(' ') };
        renderBeerResultsForSample(sampleId);
        renderBeerCompareTab();
        return;
      }
      const measurementCount = measurementData.length;
      if (measurementCount === 0) {
        beerState.results[sampleId] = { error: 'No valid path length data available.' };
        renderBeerResultsForSample(sampleId);
        renderBeerCompareTab();
        return;
      }
      const slopes = new Array(BEER_WAVELENGTHS.length).fill(0);
      const intercepts = new Array(BEER_WAVELENGTHS.length).fill(0);
      const pathMeters = measurementData.map(m => m.parsed.meters);
      for (let i = 0; i < BEER_WAVELENGTHS.length; i++) {
        const yVals = measurementData.map(m => m.processed[i]);
        if (measurementCount === 1) {
          slopes[i] = yVals[0] / pathMeters[0];
          intercepts[i] = 0;
        } else if (state.beerForceOrigin) {
          let num = 0;
          let den = 0;
          for (let j = 0; j < measurementCount; j++) {
            const x = pathMeters[j];
            num += x * yVals[j];
            den += x * x;
          }
          slopes[i] = den === 0 ? 0 : num / den;
          intercepts[i] = 0;
        } else {
          let sumX = 0, sumY = 0, sumXX = 0, sumXY = 0;
          for (let j = 0; j < measurementCount; j++) {
            const x = pathMeters[j];
            const y = yVals[j];
            sumX += x;
            sumY += y;
            sumXX += x * x;
            sumXY += x * y;
          }
          const denom = measurementCount * sumXX - sumX * sumX;
          if (Math.abs(denom) < 1e-12) {
            slopes[i] = 0;
            intercepts[i] = sumY / measurementCount;
          } else {
            slopes[i] = (measurementCount * sumXY - sumX * sumY) / denom;
            intercepts[i] = (sumY - slopes[i] * sumX) / measurementCount;
          }
        }
      }
      const reference = BEER_REFERENCES[state.beerColorRef] || BEER_REFERENCES.d65;
      const colourData = computeBeerColours(slopes, intercepts, BEER_DEPTHS, reference);
      const diag = {};
      if (measurementCount > 1) {
        [450, 500, 560].forEach(wl => {
          const idx = (wl - 400) / 10;
          if (idx < 0 || idx >= BEER_WAVELENGTHS.length) return;
          const yVals = measurementData.map(m => m.processed[idx]);
          let mean = 0;
          yVals.forEach(v => { mean += v; });
          mean /= measurementCount;
          let ssTot = 0;
          let ssRes = 0;
          for (let j = 0; j < measurementCount; j++) {
            const x = pathMeters[j];
            const pred = slopes[idx] * x + intercepts[idx];
            const diff = yVals[j] - mean;
            ssTot += diff * diff;
            const resid = yVals[j] - pred;
            ssRes += resid * resid;
          }
          diag[wl] = ssTot === 0 ? 1 : 1 - ssRes / ssTot;
        });
      }
      beerState.results[sampleId] = {
        colours: colourData.results,
        referenceKey: state.beerColorRef,
        pathRaw: parsedMain.raw,
        pathUnit: parsedMain.unit,
        pathMeters: parsedMain.meters,
        clampApplied: state.beerClampNeg,
        baselineApplied: state.beerBaseline,
        baselineShift: measurementData[0] ? measurementData[0].baselineShift : 0,
        pathDetails: measurementData.map(m => ({
          label: m.label,
          pathRaw: m.parsed.raw,
          pathUnit: m.parsed.unit,
          pathMeters: m.parsed.meters,
          sampleId: m.sampleId,
          sampleName: m.sampleName,
          baselineShift: m.baselineShift
        })),
        singlePoint: measurementCount === 1,
        r2: diag
      };
      renderBeerResultsForSample(sampleId);
      renderBeerCompareTab();
    }
    function renderBeerLambert() {
      const list = document.getElementById('beerSampleList');
      if (!list) return;
      const selectedIds = state.selectedOrder.filter(id => state.selected.has(id));
      cleanupBeerState(state.samples.map(s => s.id));
      list.innerHTML = '';
      if (selectedIds.length === 0) {
        const msg = document.createElement('div');
        msg.className = 'beer-empty';
        msg.textContent = 'Select one or more samples to begin.';
        list.appendChild(msg);
        renderBeerCompareTab();
        return;
      }
      selectedIds.forEach(id => {
        const sample = getSampleById(id);
        if (!sample) return;
        const entry = ensureBeerEntry(id);
        const card = document.createElement('div');
        card.className = 'beer-sample-card';
        card.dataset.sampleId = id;
        const header = document.createElement('div');
        header.className = 'beer-sample-header';
        const titleWrap = document.createElement('div');
        titleWrap.className = 'beer-sample-title';
        const chip = document.createElement('span');
        chip.className = 'beer-color-chip';
        chip.style.backgroundColor = getSampleColor(sample);
        titleWrap.appendChild(chip);
        const name = document.createElement('span');
        name.textContent = getSampleLabel(sample);
        titleWrap.appendChild(name);
        if (sample['No.']) {
          const code = document.createElement('span');
          code.className = 'beer-sample-code';
          code.textContent = `#${sample['No.']}`;
          titleWrap.appendChild(code);
        }
        header.appendChild(titleWrap);
        const extrasWrapper = document.createElement('div');
        extrasWrapper.className = 'beer-extra-wrapper';
        const mainRow = document.createElement('div');
        mainRow.className = 'beer-extra-row beer-main-row';
        const mainLabel = document.createElement('span');
        mainLabel.className = 'beer-extra-label';
        mainLabel.textContent = 'Path length:';
        mainRow.appendChild(mainLabel);
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'e.g. 10';
        input.value = entry.main.raw || '';
        input.dataset.sampleId = id;
        mainRow.appendChild(input);
        const unitLabel = document.createElement('span');
        unitLabel.className = 'beer-extra-label';
        unitLabel.textContent = 'Unit:';
        unitLabel.style.opacity = '0.7';
        mainRow.appendChild(unitLabel);
        const select = document.createElement('select');
        BEER_PATH_UNITS.forEach(unit => {
          const opt = document.createElement('option');
          opt.value = unit;
          opt.textContent = unit;
          select.appendChild(opt);
        });
        select.value = entry.main.unit || 'mm';
        mainRow.appendChild(select);
        extrasWrapper.appendChild(mainRow);
        header.appendChild(extrasWrapper);
        card.appendChild(header);
        input.addEventListener('input', () => {
          const current = ensureBeerEntry(id);
          current.main.raw = input.value;
          state.beerPaths[id] = current;
          computeBeerForSample(id);
        });
        select.addEventListener('change', () => {
          const current = ensureBeerEntry(id);
          current.main.unit = select.value;
          state.beerPaths[id] = current;
          computeBeerForSample(id);
        });
        entry.extras.forEach((extra, extraIndex) => {
          const row = document.createElement('div');
          row.className = 'beer-extra-row';
          if (!extra.enabled) row.classList.add('disabled');
          const toggleLabel = document.createElement('label');
          const toggle = document.createElement('input');
          toggle.type = 'checkbox';
          toggle.checked = !!extra.enabled;
          toggleLabel.appendChild(toggle);
          toggleLabel.appendChild(document.createTextNode(`Extra path ${extraIndex + 1}`));
          row.appendChild(toggleLabel);
          const extraInput = document.createElement('input');
          extraInput.type = 'text';
          extraInput.placeholder = 'Length';
          extraInput.value = extra.raw || '';
          extraInput.disabled = !extra.enabled;
          row.appendChild(extraInput);
          const unitSelect = document.createElement('select');
          BEER_PATH_UNITS.forEach(unit => {
            const opt = document.createElement('option');
            opt.value = unit;
            opt.textContent = unit;
            unitSelect.appendChild(opt);
          });
          unitSelect.value = extra.unit || 'mm';
          unitSelect.disabled = !extra.enabled;
          row.appendChild(unitSelect);
          const sampleSelect = document.createElement('select');
          sampleSelect.disabled = !extra.enabled;
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = 'Select sample';
          sampleSelect.appendChild(placeholder);
          state.samples.forEach(smpl => {
            const opt = document.createElement('option');
            opt.value = String(smpl.id);
            const label = getSampleLabel(smpl);
            if (smpl['No.'] && smpl['No.'] !== label) {
              opt.textContent = `${label} (#${smpl['No.']})`;
            } else {
              opt.textContent = label;
            }
            if (String(extra.sourceId) === String(smpl.id)) opt.selected = true;
            sampleSelect.appendChild(opt);
          });
          sampleSelect.value = extra.sourceId ? String(extra.sourceId) : '';
          row.appendChild(sampleSelect);
          function updateDisabledState() {
            row.classList.toggle('disabled', !toggle.checked);
            extraInput.disabled = !toggle.checked;
            unitSelect.disabled = !toggle.checked;
            sampleSelect.disabled = !toggle.checked;
          }
          toggle.addEventListener('change', () => {
            const current = ensureBeerEntry(id);
            const currentExtra = current.extras[extraIndex];
            currentExtra.enabled = toggle.checked;
            state.beerPaths[id] = current;
            updateDisabledState();
            computeBeerForSample(id);
          });
          extraInput.addEventListener('input', () => {
            const current = ensureBeerEntry(id);
            const currentExtra = current.extras[extraIndex];
            currentExtra.raw = extraInput.value;
            state.beerPaths[id] = current;
            if (currentExtra.enabled) computeBeerForSample(id);
          });
          unitSelect.addEventListener('change', () => {
            const current = ensureBeerEntry(id);
            const currentExtra = current.extras[extraIndex];
            currentExtra.unit = unitSelect.value;
            state.beerPaths[id] = current;
            if (currentExtra.enabled) computeBeerForSample(id);
          });
          sampleSelect.addEventListener('change', () => {
            const current = ensureBeerEntry(id);
            const currentExtra = current.extras[extraIndex];
            currentExtra.sourceId = sampleSelect.value;
            state.beerPaths[id] = current;
            if (currentExtra.enabled) computeBeerForSample(id);
          });
          updateDisabledState();
          extrasWrapper.appendChild(row);
        });
        const resultsDiv = document.createElement('div');
        resultsDiv.className = 'beer-results';
        resultsDiv.dataset.sampleId = id;
        card.appendChild(resultsDiv);
        list.appendChild(card);
        if (entry.main.raw && entry.main.raw.trim()) {
          computeBeerForSample(id);
        } else {
          renderBeerResultsForSample(id, resultsDiv);
        }
      });
      renderBeerCompareTab();
    }
    function renderBeerCompareTab() {
      const container = document.getElementById('beerCompareList');
      if (!container) return;
      container.innerHTML = '';
      const selectedIds = state.selectedOrder.filter(id => state.selected.has(id));
      if (selectedIds.length === 0) {
        const msg = document.createElement('div');
        msg.className = 'beer-empty';
        msg.textContent = 'No samples selected.';
        container.appendChild(msg);
        return;
      }
      selectedIds.forEach(id => {
        const sample = getSampleById(id);
        if (!sample) return;
        const card = document.createElement('div');
        card.className = 'beer-compare-card';
        const header = document.createElement('div');
        header.className = 'beer-compare-header';
        const chip = document.createElement('span');
        chip.className = 'beer-color-chip';
        chip.style.backgroundColor = getSampleColor(sample);
        header.appendChild(chip);
        const title = document.createElement('span');
        title.textContent = getSampleLabel(sample);
        header.appendChild(title);
        if (sample['No.']) {
          const code = document.createElement('span');
          code.className = 'beer-sample-code';
          code.textContent = `#${sample['No.']}`;
          header.appendChild(code);
        }
        card.appendChild(header);
        const entry = ensureBeerEntry(id);
        const result = beerState.results[id];
        if (!entry.main.raw || !entry.main.raw.trim()) {
          card.classList.add('disabled');
          const msg = document.createElement('div');
          msg.className = 'beer-empty';
          msg.textContent = 'Add a path length in Color Extrapolation.';
          card.appendChild(msg);
        } else if (!result || result.error) {
          card.classList.add('disabled');
          const err = document.createElement('div');
          err.className = 'beer-error';
          err.textContent = result && result.error ? result.error : 'Unable to compute colours.';
          card.appendChild(err);
        } else {
          const strip = document.createElement('div');
          strip.className = 'beer-compare-strip';
          result.colours.forEach(col => {
            const swatch = document.createElement('div');
            swatch.className = 'beer-compare-swatch';
            swatch.style.backgroundColor = `rgb(${col.srgb[0]},${col.srgb[1]},${col.srgb[2]})`;
            const span = document.createElement('span');
            span.textContent = `${(col.depth_m * 100).toFixed(0)} cm`;
            swatch.appendChild(span);
            strip.appendChild(swatch);
          });
          card.appendChild(strip);
        }
        container.appendChild(card);
      });
    }
    function recomputeAllBeerSamples() {
      const selectedIds = state.selectedOrder.filter(id => state.selected.has(id));
      selectedIds.forEach(id => {
        const entry = ensureBeerEntry(id);
        if (entry.main.raw && entry.main.raw.trim()) {
          computeBeerForSample(id);
        } else {
          delete beerState.results[id];
          renderBeerResultsForSample(id);
        }
      });
      renderBeerCompareTab();
    }
    function drawAll() {
      updateTable();
      renderBeerLambert();
      if (state.activeTab === 'scales') drawScales();
      else if (state.activeTab === 'cielab') {
        drawAB();
        drawL();
      }
      else if (state.activeTab === 'spectrum') drawSpectrum();
      else if (state.activeTab === 'beer') {
        // Beer-Lambert tab is DOM-driven; nothing extra to draw here.
      }
      else if (state.activeTab === 'beer-compare') {
        renderBeerCompareTab();
      }
      else if (state.activeTab === 'compare') drawCompare();
      else if (state.activeTab === 'details') drawDetails();
    }

    // ----------------------------
    // redraw scheduling helper
    // ----------------------------
    // When updating the UI, we frequently need to redraw charts. If we call
    // drawAll() synchronously during certain events (e.g. file load, selection
    // toggles) the SVG elements may not yet have a proper width/height
    // because the browser hasnâ€™t laid out the DOM. To avoid drawing into a
    // zeroâ€‘sized canvas, we provide a scheduleDraw() helper that uses
    // requestAnimationFrame. It coalesces multiple redraw requests into a
    // single frame and only schedules one at a time.
    let drawScheduled = false;
    function scheduleDraw() {
      if (drawScheduled) return;
      drawScheduled = true;
      requestAnimationFrame(() => {
        drawScheduled = false;
        drawAll();
      });
    }
    // Tooltip management
    const tooltip = document.getElementById('tooltip');
    function showTooltip(x,y,content) {
      tooltip.style.display = 'block';
      tooltip.style.left = (x + 10) + 'px';
      tooltip.style.top = (y + 10) + 'px';
      tooltip.textContent = content;
    }
    function hideTooltip() {
      tooltip.style.display = 'none';
    }
    async function importFiles(files) {
      const fileArray = files.filter(Boolean);
      if (!fileArray.length) return;
      let addedCount = 0;
      let allWarnings = [];
      const existingIds = new Set(state.samples.map(s => s.id));
      for (const file of fileArray) {
        const text = await file.text();
        const {samples: parsedSamples, warnings} = parseCSV(text);
        const seenIds = new Set();
        const uniqueSamples = [];
        parsedSamples.forEach(sample => {
          const key = sample.id;
          if (!key && key !== 0) return;
          if (existingIds.has(key) || seenIds.has(key)) return;
          seenIds.add(key);
          uniqueSamples.push(sample);
        });
        assignDefaultColors(uniqueSamples);
        uniqueSamples.forEach(sample => {
          state.samples.push(sample);
          state.selected.add(sample.id);
          if (!state.selectedOrder.includes(sample.id)) {
            state.selectedOrder.push(sample.id);
          }
          existingIds.add(sample.id);
          addedCount++;
        });
        if (warnings && warnings.length) allWarnings.push(...warnings);
      }
      if (addedCount) {
        setProjectTitle('');
      }
      updateWarning(allWarnings);
      updateIlluminantOptions();
      persistState();
      scheduleDraw();
    }
    // Event listeners
    document.getElementById('uploadZone').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });
    document.getElementById('fileInput').addEventListener('change', async (ev) => {
      await importFiles(Array.from(ev.target.files));
      // Clear value so selecting same file again triggers change
      ev.target.value = '';
    });
    // Drag and drop
    document.getElementById('uploadZone').addEventListener('dragover', (ev) => {
      ev.preventDefault();
      ev.currentTarget.classList.add('dragover');
    });
    document.getElementById('uploadZone').addEventListener('dragleave', (ev) => {
      ev.currentTarget.classList.remove('dragover');
    });
    document.getElementById('uploadZone').addEventListener('drop', async (ev) => {
      ev.preventDefault();
      ev.currentTarget.classList.remove('dragover');
      const files = Array.from(ev.dataTransfer.files).filter(f => /\.csv$/i.test(f.name));
      await importFiles(files);
    });
    document.getElementById('selectAll').addEventListener('change', (ev) => {
      const checked = ev.target.checked;
      filteredSamples().forEach(sample => {
        if (checked) {
          state.selected.add(sample.id);
          if (!state.selectedOrder.includes(sample.id)) state.selectedOrder.push(sample.id);
        } else {
          state.selected.delete(sample.id);
          state.selectedOrder = state.selectedOrder.filter(id => id !== sample.id);
        }
      });
      persistState();
      scheduleDraw();
    });
    document.getElementById('illuminantFilter').addEventListener('change', (ev) => {
      state.illuminantFilter = ev.target.value;
      persistState();
      scheduleDraw();
    });
    document.getElementById('groupByIlluminant').addEventListener('change', (ev) => {
      state.groupByIlluminant = ev.target.checked;
      persistState();
      scheduleDraw();
    });
    document.getElementById('hideUnselected').addEventListener('change', (ev) => {
      state.hideUnselected = ev.target.checked;
      persistState();
      scheduleDraw();
    });
    document.getElementById('searchBox').addEventListener('input', (ev) => {
      state.search = ev.target.value;
      persistState();
      scheduleDraw();
    });
    document.querySelectorAll('.tabs button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tabs button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.activeTab = btn.dataset.tab;
        persistState();
        document.querySelectorAll('.tab-content').forEach(tc => tc.style.display = 'none');
        document.getElementById('tab-' + state.activeTab).style.display = 'block';
        scheduleDraw();
      });
    });
    document.getElementById('logScale').addEventListener('change', (ev) => {
      state.logScale = ev.target.checked;
      persistState();
      if (state.activeTab === 'spectrum') drawSpectrum();
    });
    document.getElementById('smoothToggle').addEventListener('change', (ev) => {
      state.smooth = ev.target.checked;
      persistState();
      if (state.activeTab === 'spectrum') drawSpectrum();
    });
    document.getElementById('smoothWindow').addEventListener('input', (ev) => {
      const v = parseInt(ev.target.value);
      state.smoothWindow = v;
      persistState();
      if (state.activeTab === 'spectrum' && state.smooth) drawSpectrum();
    });
    document.getElementById('shadeArea').addEventListener('change', (ev) => {
      state.shadeArea = ev.target.checked;
      persistState();
      if (state.activeTab === 'spectrum') drawSpectrum();
    });
    document.getElementById('yMaxInput').addEventListener('input', (ev) => {
      const v = parseFloat(ev.target.value);
      state.yMax = isFinite(v) && v > 0 ? v : null;
      persistState();
      if (state.activeTab === 'spectrum') drawSpectrum();
    });

    const beerClamp = document.getElementById('beerClampNeg');
    if (beerClamp) {
      beerClamp.checked = !!state.beerClampNeg;
      beerClamp.addEventListener('change', (ev) => {
        state.beerClampNeg = ev.target.checked;
        persistState();
        recomputeAllBeerSamples();
      });
    }
    const beerBaseline = document.getElementById('beerBaseline');
    if (beerBaseline) {
      beerBaseline.checked = !!state.beerBaseline;
      beerBaseline.addEventListener('change', (ev) => {
        state.beerBaseline = ev.target.checked;
        persistState();
        recomputeAllBeerSamples();
      });
    }
    const beerForce = document.getElementById('beerForceOrigin');
    if (beerForce) {
      beerForce.checked = !!state.beerForceOrigin;
      beerForce.addEventListener('change', (ev) => {
        state.beerForceOrigin = ev.target.checked;
        persistState();
        recomputeAllBeerSamples();
      });
    }
    const beerRef = document.getElementById('beerColorRef');
    if (beerRef) {
      beerRef.value = state.beerColorRef || 'd65';
      beerRef.addEventListener('change', (ev) => {
        state.beerColorRef = ev.target.value;
        persistState();
        recomputeAllBeerSamples();
      });
    }

    // Delete selected samples button
      document.getElementById('deleteSamples').addEventListener('click', () => {
        const ids = Array.from(state.selected);
        if (ids.length === 0) {
          alert(t('noSamplesToDelete'));
          return;
        }
      // Remove samples whose id is in the selected set
      state.samples = state.samples.filter(s => !state.selected.has(s.id));
      // Clear current selection and reset last clicked if necessary
      state.selected.clear();
      state.selectedOrder = [];
      if (state.lastClicked && ids.includes(state.lastClicked)) {
        state.lastClicked = null;
      }
      updateIlluminantOptions();
      // Do not persist samples, but UI state remains
      scheduleDraw();
      drawDetails();
    });
    // Delete unselected samples button
      document.getElementById('deleteUnselected').addEventListener('click', () => {
        const remaining = state.samples.filter(s => state.selected.has(s.id));
        if (remaining.length === state.samples.length) {
          alert(t('noUnselectedToDelete'));
          return;
        }
      state.samples = remaining;
      if (state.lastClicked && !state.selected.has(state.lastClicked)) {
        state.lastClicked = null;
      }
      updateIlluminantOptions();
      // Do not persist samples, but UI state remains
      scheduleDraw();
      drawDetails();
    });
    // Dark mode toggle
    const themeToggle = document.getElementById('themeToggle');
    themeToggle.addEventListener('click', () => {
      // Flip between light and dark themes. Remove both theme classes and
      // then add the selected one. This overrides the OS preference.
      state.theme = state.theme === 'dark' ? 'light' : 'dark';
      applyTheme();
      persistState();
    });

    const languageToggle = document.getElementById('languageToggle');
    languageToggle.textContent = state.language === 'en' ? 'FR' : 'EN';
    languageToggle.addEventListener('click', () => {
      state.language = state.language === 'en' ? 'fr' : 'en';
      languageToggle.textContent = state.language === 'en' ? 'FR' : 'EN';
      applyTranslations();
      updateIlluminantOptions();
      persistState();
    });

    async function saveContentFile({ content, mimeType, suggestedName }) {
      if (window.showSaveFilePicker) {
        const handle = await window.showSaveFilePicker({
          suggestedName,
          types: [{ description: 'File', accept: { [mimeType]: ['.' + suggestedName.split('.').pop()] } }]
        });
        const writable = await handle.createWritable();
        await writable.write(new Blob([content], { type: mimeType }));
        await writable.close();
      } else {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = suggestedName;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
      }
    }

    document.getElementById('exportProjectJson').addEventListener('click', async () => {
      if (state.samples.length === 0) {
        alert(t('noDataToSave'));
        return;
      }
      try {
        const payload = buildProjectPayload();
        await saveContentFile({
          content: JSON.stringify(payload, null, 2),
          mimeType: 'application/json',
          suggestedName: (state.projectName || 'project') + '.json'
        });
      } catch (err) {
        console.error('Error exporting JSON', err);
        alert(t('couldNotSaveFile'));
      }
    });

    const projectImport = document.getElementById('projectImport');
    document.getElementById('importProjectJson').addEventListener('click', () => {
      projectImport.click();
    });
    projectImport.addEventListener('change', async (ev) => {
      const file = ev.target.files && ev.target.files[0];
      if (!file) return;
      try {
        const data = JSON.parse(await file.text());
        if (!applyProjectData(data)) throw new Error('Invalid project payload');
        applyTheme();
        applyTranslations();
        syncControlsFromState();
        updateIlluminantOptions();
        updateTable();
        renderBeerLambert();
        renderBeerCompareTab();
        scheduleDraw();
        drawDetails();
        persistState();
      } catch (err) {
        console.error('Error importing JSON', err);
        alert(t('invalidProjectFile'));
      } finally {
        ev.target.value = '';
      }
    });

    const sidebar = document.getElementById('sidebar');
    // Toggle main panel visibility (hide/show charts)
      const togglePanelBtn = document.getElementById('toggleMainPanel');
      togglePanelBtn.addEventListener('click', () => {
        const containerEl = document.getElementById('container');
        const hide = containerEl.classList.toggle('hide-main');
        if (hide) sidebar.style.width = '';
        // Update the button title to reflect the action when clicked next
        togglePanelBtn.title = hide ? t('showCharts') : t('hideCharts');
      });

    const divider = document.getElementById('divider');
    divider.addEventListener('mousedown', startDrag);
    function startDrag(e) {
      e.preventDefault();
      divider.classList.add('dragging');
      document.addEventListener('mousemove', onDrag);
      document.addEventListener('mouseup', stopDrag);
    }
    function onDrag(e) {
      const containerRect = document.getElementById('container').getBoundingClientRect();
      let newWidth = e.clientX - containerRect.left;
      const min = 150;
      const max = containerRect.width - 200;
      if (newWidth < min) newWidth = min;
      if (newWidth > max) newWidth = max;
      sidebar.style.width = newWidth + 'px';
    }
    function stopDrag() {
      divider.classList.remove('dragging');
      document.removeEventListener('mousemove', onDrag);
      document.removeEventListener('mouseup', stopDrag);
    }

    // Save Project button
      document.getElementById('saveProject').addEventListener('click', async () => {
        if (state.samples.length === 0) {
          alert(t('noDataToSave'));
          return;
        }
        if (!window.showSaveFilePicker) {
          alert(t('couldNotSaveFile'));
          return;
        }
        let handle;
        try {
          handle = await window.showSaveFilePicker({
            suggestedName: (state.projectName || 'project') + '.html',
            types: [{
              description: 'HTML Files',
              accept: { 'text/html': ['.html'] }
            }]
          });
        } catch (err) {
          if (err.name === 'AbortError') return; // user cancelled
          console.error('Error saving file', err);
          alert(t('couldNotSaveFile'));
          return;
        }
        const name = handle.name.replace(/\.html$/i, '');
        setProjectTitle(name);
        persistState();
        let dataEl = document.getElementById('projectData');
        if (!dataEl) {
          dataEl = document.createElement('script');
          dataEl.id = 'projectData';
          dataEl.type = 'application/json';
          appScript.parentNode.insertBefore(dataEl, appScript);
        }
        const projectState = buildProjectPayload();
        dataEl.textContent = JSON.stringify(projectState);
        const html = '<!DOCTYPE html>\\n' + document.documentElement.outerHTML;
        const writable = await handle.createWritable();
        await writable.write(new Blob([html], { type: 'text/html' }));
        await writable.close();
      });

    // Initialize initial render
    // Apply persisted theme before first render to avoid flash. We remove any
    // existing theme classes and add either .dark or .light to explicitly
    // override the OS preference. This ensures the toggle fully controls
    // the colour scheme.
    applyTheme();

    syncControlsFromState();

    updateIlluminantOptions();
    updateTable();
    renderBeerLambert();
    renderBeerCompareTab();
    if (state.activeTab === 'scales') drawScales();
    else if (state.activeTab === 'cielab') { drawAB(); drawL(); }
    else if (state.activeTab === 'spectrum') drawSpectrum();
    else if (state.activeTab === 'beer') {
      renderBeerLambert();
    }
    else if (state.activeTab === 'beer-compare') {
      renderBeerCompareTab();
    }
    else if (state.activeTab === 'compare') drawCompare();
    else drawDetails();
    // restore selected sample colors and details
    drawDetails();

    // Observe container resizing to redraw charts so they fit within the panel
    try {
      const resObs = new ResizeObserver(() => {
        // Reâ€‘draw current active tab when the main container or its children resize
        scheduleDraw();
      });
      // Observe the main content area which contains the tab panels
      resObs.observe(document.getElementById('main'));
    } catch (e) {
      // Fallback: redraw on window resize if ResizeObserver unsupported
      window.addEventListener('resize', drawAll);
    }
  })();
  </script>
</body>
</html>
